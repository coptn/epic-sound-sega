<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Aeneas: Descent to the Underworld</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Philosopher:ital@0;1&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Philosopher', serif;
      touch-action: none;
      user-select: none;
    }
    
    #game-container {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 1;
      pointer-events: none;
    }
    
    canvas { 
      display: block; 
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    /* Title Screen */
    #title-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(180deg, #0a0a1a 0%, #1a0a2a 50%, #0a0a0a 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      pointer-events: auto;
    }
    
    #title-screen h1 {
      font-family: 'Cinzel', serif;
      font-size: 3rem;
      color: #ffd700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 150, 0, 0.5);
      text-align: center;
      margin-bottom: 10px;
    }
    
    #title-screen h2 {
      font-family: 'Cinzel', serif;
      font-size: 1.5rem;
      color: #aaa;
      margin-bottom: 40px;
    }
    
    .platform-selection {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .platform-btn {
      padding: 15px 40px;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      background: rgba(30, 20, 50, 0.8);
      color: #c9a227;
      border: 2px solid #4a3a6a;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      pointer-events: auto;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .platform-btn.active {
      background: linear-gradient(135deg, #c9a227, #8b6914);
      color: #000;
      border-color: #ffd700;
      box-shadow: 0 0 25px rgba(201, 162, 39, 0.6);
    }
    
    .start-btn {
      padding: 20px 60px;
      font-family: 'Cinzel', serif;
      font-size: 1.4rem;
      background: linear-gradient(135deg, #c9a227, #8b6914);
      color: #000;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 5px 30px rgba(201, 162, 39, 0.5);
      transition: transform 0.2s;
      pointer-events: auto;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .start-btn:hover { transform: scale(1.05); }
    .start-btn:active { transform: scale(0.98); }
    
    #controls-hint {
      margin-top: 30px;
      color: #666;
      font-size: 0.9rem;
      text-align: center;
      max-width: 400px;
    }
    
    /* Fade Overlay */
    #fade-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 500;
      transition: opacity 0.5s;
    }
    
    #fade-overlay.white { background: #fff; }
    #fade-overlay.active { opacity: 1; }

    /* Death Image Flash Overlay */
    #death-flash-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9998;
      pointer-events: none;
    }

    #death-flash-overlay img {
      max-width: 80%;
      max-height: 80%;
      object-fit: contain;
    }

    #death-flash-overlay.active {
      display: flex;
    }
    
    /* Narrator Box */
    #narrator-box {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 700px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #7a6a4a;
      border-radius: 15px;
      padding: 20px 25px;
      color: #e8e0d0;
      font-size: 1.1rem;
      font-style: italic;
      line-height: 1.6;
      text-align: center;
      display: none;
      z-index: 200;
    }
    
    #narrator-box .speaker {
      color: #ffd700;
      font-weight: bold;
      font-style: normal;
      margin-bottom: 8px;
      font-family: 'Cinzel', serif;
    }
    
    #narrator-box .tap-hint {
      color: #666;
      font-size: 0.8rem;
      margin-top: 12px;
    }
    
    /* Inventory */
    #inventory {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 10px;
      z-index: 150;
    }
    
    .inv-slot {
      width: 70px;
      height: 70px;
      background: rgba(20, 15, 30, 0.85);
      border: 2px solid #5a4a3a;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: #ffd700;
      position: relative;
    }
    
    .inv-slot.active {
      border-color: #ffd700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }
    
    .inv-slot .slot-num {
      position: absolute;
      top: 3px;
      left: 6px;
      font-size: 0.7rem;
      color: #888;
    }
    
    /* Health Bar */
    #health-bar {
      position: fixed;
      top: 20px;
      left: 20px;
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 150;
    }
    
    #health-bar .hearts {
      display: flex;
      gap: 8px;
    }
    
    #health-bar .heart {
      font-size: 2rem;
      color: #ff4444;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      transition: all 0.3s;
    }
    
    #health-bar .heart.lost {
      color: #333;
      text-shadow: none;
    }

    /* Player Lives with Health Bars */
    #player-lives {
      position: fixed;
      top: 20px;
      left: 20px;
      display: none;
      flex-direction: column;
      gap: 8px;
      z-index: 150;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 12px;
      border: 2px solid #ff4444;
    }

    #player-lives .lives-title {
      color: #ffd700;
      font-family: 'Cinzel', serif;
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .life-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .life-icon {
      font-size: 1.5rem;
    }

    .life-bar {
      width: 100px;
      height: 12px;
      background: #333;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #555;
    }

    .life-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff4444, #ff6666);
      transition: width 0.3s;
      border-radius: 6px;
    }

    .life-bar-container.lost .life-icon {
      filter: grayscale(100%);
      opacity: 0.4;
    }

    .life-bar-container.lost .life-bar-fill {
      width: 0% !important;
      background: #333;
    }

    /* Hades Health Bar */
    #hades-health-bar {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 150;
      background: rgba(10, 0, 20, 0.9);
      padding: 15px 30px;
      border-radius: 15px;
      border: 3px solid #8800ff;
      box-shadow: 0 0 30px rgba(136, 0, 255, 0.5);
      overflow: visible;
    }

    /* Boss-battle messages: non-blocking stack above boss bar */
    #boss-messages {
      position: absolute;
      left: 50%;
      top: -12px;
      transform: translate(-50%, -100%);
      width: min(560px, calc(100vw - 40px));
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
      z-index: 200;
    }

    .boss-msg {
      background: rgba(0, 0, 0, 0.75);
      border: 1px solid rgba(255, 0, 255, 0.45);
      box-shadow: 0 0 18px rgba(255, 0, 255, 0.25);
      border-radius: 12px;
      padding: 10px 14px;
      color: #f4e9ff;
      font-size: 1rem;
      line-height: 1.35;
      backdrop-filter: blur(6px);
    }

    .boss-msg .boss-speaker {
      display: block;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      color: #ff00ff;
      margin-bottom: 4px;
      text-shadow: 0 0 10px rgba(255, 0, 255, 0.6);
    }

    #hades-health-bar .boss-name {
      font-family: 'Cinzel', serif;
      color: #ff00ff;
      font-size: 1.4rem;
      text-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
      margin-bottom: 10px;
    }

    #hades-health-bar .health-bar-outer {
      width: 400px;
      height: 25px;
      background: #1a0a2a;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #440066;
    }

    #hades-health-bar .health-bar-inner {
      height: 100%;
      background: linear-gradient(90deg, #8800ff, #ff00ff, #8800ff);
      transition: width 0.3s;
      box-shadow: 0 0 15px rgba(136, 0, 255, 0.8);
    }

    #hades-health-bar .health-text {
      color: #ccc;
      font-size: 0.9rem;
      margin-top: 5px;
    }

    /* Victory Screen */
    #victory-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      transition: background 2s;
    }

    #victory-screen.active {
      background: rgba(0, 0, 0, 1);
    }

    #victory-screen h1 {
      font-family: 'Cinzel', serif;
      font-size: 4rem;
      color: #ffd700;
      text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
      opacity: 0;
      transition: opacity 1s;
    }

    #victory-screen.show-text h1 {
      opacity: 1;
    }

    #victory-screen .victory-subtitle {
      font-family: 'Philosopher', serif;
      font-size: 1.5rem;
      color: #aaa;
      margin-top: 20px;
      opacity: 0;
      transition: opacity 1s 0.5s;
    }

    #victory-screen.show-text .victory-subtitle {
      opacity: 1;
    }

    #victory-screen .end-btn {
      margin-top: 40px;
      padding: 15px 50px;
      font-family: 'Cinzel', serif;
      font-size: 1.2rem;
      background: linear-gradient(135deg, #c9a227, #8b6914);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 1s 1s, transform 0.2s;
    }

    #victory-screen.show-text .end-btn {
      opacity: 1;
    }

    #victory-screen .end-btn:hover {
      transform: scale(1.05);
    }

    /* Throne Sit Button */
    #throne-sit-btn {
      position: fixed;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      padding: 20px 50px;
      font-family: 'Cinzel', serif;
      font-size: 1.3rem;
      background: linear-gradient(135deg, #8800ff, #440066);
      color: #fff;
      border: 3px solid #ff00ff;
      border-radius: 15px;
      cursor: pointer;
      display: none;
      z-index: 200;
      box-shadow: 0 0 30px rgba(136, 0, 255, 0.6);
      transition: all 0.3s;
    }

    #throne-sit-btn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.8);
    }

    /* Portal Password UI */
    #portal-password-ui {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(ellipse at center, rgba(136, 0, 255, 0.95) 0%, rgba(20, 0, 40, 0.98) 100%);
      border: 4px solid #ff00ff;
      border-radius: 25px;
      padding: 40px 50px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 500;
      box-shadow: 0 0 60px rgba(255, 0, 255, 0.8), inset 0 0 40px rgba(136, 0, 255, 0.3);
      animation: portalPulse 2s ease-in-out infinite;
    }

    @keyframes portalPulse {
      0%, 100% { box-shadow: 0 0 60px rgba(255, 0, 255, 0.8), inset 0 0 40px rgba(136, 0, 255, 0.3); }
      50% { box-shadow: 0 0 100px rgba(255, 0, 255, 1), inset 0 0 60px rgba(136, 0, 255, 0.5); }
    }

    @keyframes shake {
      0%, 100% { transform: translate(-50%, -50%); }
      10%, 30%, 50%, 70%, 90% { transform: translate(-52%, -50%); }
      20%, 40%, 60%, 80% { transform: translate(-48%, -50%); }
    }

    #portal-password-ui h2 {
      font-family: 'Cinzel', serif;
      color: #ff00ff;
      font-size: 1.8rem;
      text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
      margin-bottom: 10px;
      text-align: center;
    }

    #portal-password-ui p {
      color: #d4a8ff;
      font-size: 1.1rem;
      font-style: italic;
      margin-bottom: 25px;
      text-align: center;
    }

    #portal-password-input {
      width: 150px;
      padding: 15px;
      font-family: 'Cinzel', serif;
      font-size: 2rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid #aa00ff;
      border-radius: 12px;
      color: #fff;
      letter-spacing: 8px;
      margin-bottom: 20px;
      outline: none;
    }

    #portal-password-input:focus {
      border-color: #ff00ff;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    #portal-password-input::placeholder {
      color: #666;
      letter-spacing: 0;
    }

    .portal-btn-row {
      display: flex;
      gap: 15px;
    }

    .portal-btn {
      padding: 12px 30px;
      font-family: 'Cinzel', serif;
      font-size: 1.1rem;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .portal-btn.enter {
      background: linear-gradient(135deg, #8800ff, #ff00ff);
      color: #fff;
      border: 2px solid #ff00ff;
    }

    .portal-btn.enter:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.7);
    }

    .portal-btn.cancel {
      background: rgba(50, 50, 50, 0.8);
      color: #aaa;
      border: 2px solid #555;
    }

    .portal-btn.cancel:hover {
      background: rgba(80, 50, 50, 0.8);
      border-color: #aa5555;
    }

    #portal-error {
      color: #ff4444;
      font-size: 0.9rem;
      margin-top: 15px;
      min-height: 20px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
    }
    
    /* Body Switch Menu */
    #body-switch-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 5, 20, 0.95);
      border: 3px solid #6a5a8a;
      border-radius: 20px;
      padding: 30px;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 400;
    }
    
    #body-switch-menu h2 {
      font-family: 'Cinzel', serif;
      color: #ffd700;
      margin-bottom: 25px;
    }
    
    .body-options {
      display: flex;
      gap: 30px;
    }
    
    .body-option {
      width: 120px;
      height: 150px;
      background: rgba(40, 30, 60, 0.8);
      border: 2px solid #5a4a7a;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .body-option:hover {
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
    }
    
    .body-option .avatar {
      font-size: 3rem;
      margin-bottom: 10px;
    }
    
    .body-option .name {
      color: #ccc;
      font-family: 'Cinzel', serif;
    }
    
    /* Puzzle Room UI */
    #puzzle-ui {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(10, 5, 20, 0.85);
      border: 2px solid #6a5a8a;
      border-radius: 12px;
      padding: 15px 20px;
      display: none;
      z-index: 150;
    }
    
    #puzzle-ui h3 {
      font-family: 'Cinzel', serif;
      color: #ffd700;
      margin-bottom: 10px;
    }
    
    #puzzle-ui .orb-count {
      color: #aaa;
      font-size: 1.1rem;
    }
    
    /* Mobile Controls */
    #mobile-controls {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      display: none;
      z-index: 100;
    }
    
    #look-area {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      z-index: 1;
      touch-action: none;
    }
    
    #joystick-zone {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 200px;
      height: 200px;
      pointer-events: auto;
      z-index: 25;
      touch-action: none;
    }
    
    #move-joystick {
      position: absolute;
      left: 30px;
      bottom: 30px;
      width: 120px;
      height: 120px;
      pointer-events: auto;
      z-index: 26;
      touch-action: none;
    }
    
    #action-buttons {
      z-index: 20;
      pointer-events: auto;
      touch-action: none;
    }
    
    .joystick-base {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(201, 162, 39, 0.5);
      border-radius: 50%;
    }
    
    .joystick-knob {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, #c9a227, #6b5010);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #action-buttons {
      position: absolute;
      right: 20px;
      bottom: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      pointer-events: auto;
      z-index: 20;
    }
    
    .action-btn {
      width: 65px;
      height: 65px;
      border-radius: 50%;
      background: rgba(50, 30, 60, 0.85);
      border: 2px solid rgba(201, 162, 39, 0.7);
      color: #fff;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .action-row {
      display: flex;
      gap: 15px;
    }
    
    /* Win Screen */
    #win-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    #win-screen h1 {
      font-family: 'Cinzel', serif;
      font-size: 4rem;
      color: #ffd700;
      text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
      margin-bottom: 20px;
    }
    
    #win-screen p {
      color: #aaa;
      font-size: 1.3rem;
      margin-bottom: 30px;
    }
    
    /* Crosshair */
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      display: none;
      z-index: 100;
      pointer-events: none;
    }
    
    #crosshair::before, #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.5);
    }
    
    #crosshair::before {
      width: 2px;
      height: 8px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #crosshair::after {
      width: 8px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    /* ENHANCEMENT: Pause Menu */
    #pause-menu {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      pointer-events: auto;
    }

    #pause-content {
      background: linear-gradient(145deg, #1a1a2e, #16213e);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 40px;
      min-width: 400px;
      max-width: 90%;
      text-align: center;
    }

    #pause-content h2 {
      font-family: 'Cinzel', serif;
      color: #ffd700;
      font-size: 2.5rem;
      margin-bottom: 30px;
    }

    .pause-section {
      margin: 25px 0;
    }

    .pause-section label {
      color: #ccc;
      font-size: 1.1rem;
      display: block;
      margin-bottom: 10px;
    }

    .pause-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #333;
      outline: none;
      -webkit-appearance: none;
    }

    .pause-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ffd700;
      cursor: pointer;
    }

    .pause-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ffd700;
      cursor: pointer;
      border: none;
    }

    .pause-btn {
      padding: 15px 40px;
      margin: 10px;
      font-family: 'Cinzel', serif;
      font-size: 1.2rem;
      background: linear-gradient(145deg, #c9a227, #8b6914);
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .pause-btn:hover {
      transform: scale(1.05);
    }

    .pause-btn.danger {
      background: linear-gradient(145deg, #aa2222, #661111);
      color: #fff;
    }

    #pause-button {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(201, 162, 39, 0.8);
      border: 2px solid #ffd700;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      cursor: pointer;
      z-index: 150;
      transition: all 0.3s;
      pointer-events: auto;
    }

    #pause-button:hover {
      background: rgba(201, 162, 39, 1);
      transform: scale(1.1);
    }

    /* Cerberus Minigame */
    @keyframes warningPulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.7; }
    }

    @keyframes waveAnim {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(-50px); }
    }

    /* ============ ESCAPE ROOM PUZZLE STYLES ============ */
    #escape-room-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 600;
      background: #0a0a0f;
      cursor: none;
    }

    #escape-room-container .custom-cursor { position: fixed; width: 20px; height: 20px; border: 2px solid #e94560; border-radius: 50%; pointer-events: none; z-index: 13001; transition: transform 0.1s, background 0.2s; transform: translate(-50%, -50%); }
    #escape-room-container .custom-cursor.hovering { background: rgba(233,69,96,0.5); transform: translate(-50%,-50%) scale(1.5); }
    #escape-room-container .custom-cursor.using-item { border-color: #2ecc71; background: rgba(46,204,113,0.5); transform: translate(-50%,-50%) scale(1.8); }

    #escape-room-container .escape-game-container { width: 100%; height: 100%; perspective: 1000px; overflow: hidden; position: relative; }
    #escape-room-container .room { width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 0.05s linear; position: absolute; left: 0; top: 0; pointer-events: none; }
    #escape-room-container .wall { position: absolute; backface-visibility: hidden; pointer-events: none; }

    #escape-room-container .back-wall { width: 1000px; height: 600px; left: 50%; top: 50%; transform: translate(-50%,-50%) translateZ(-500px); border: 3px solid #e94560; box-shadow: inset 0 0 150px rgba(0,0,0,0.8), inset 0 0 50px rgba(233,69,96,0.1); }
    #escape-room-container .floor { width: 1000px; height: 1000px; left: 50%; top: 50%; background: repeating-linear-gradient(90deg,#1a1a2e 0px,#1a1a2e 48px,#0f0f1a 48px,#0f0f1a 50px), repeating-linear-gradient(0deg,#1a1a2e 0px,#1a1a2e 48px,#0f0f1a 48px,#0f0f1a 50px); transform: translate(-50%,-50%) rotateX(90deg) translateZ(-300px); pointer-events: none; }
    #escape-room-container .ceiling { width: 1000px; height: 1000px; left: 50%; top: 50%; background: linear-gradient(to bottom,#0a0a10,#12121a); transform: translate(-50%,-50%) rotateX(-90deg) translateZ(-300px); pointer-events: none; }
    #escape-room-container .left-wall { width: 1000px; height: 600px; left: 50%; top: 50%; transform: translate(-50%,-50%) rotateY(90deg) translateZ(-500px); border: 3px solid #e94560; box-shadow: inset 0 0 150px rgba(0,0,0,0.8), inset 0 0 50px rgba(233,69,96,0.1); }
    #escape-room-container .right-wall { width: 1000px; height: 600px; left: 50%; top: 50%; transform: translate(-50%,-50%) rotateY(-90deg) translateZ(-500px); border: 3px solid #e94560; box-shadow: inset 0 0 150px rgba(0,0,0,0.8), inset 0 0 50px rgba(233,69,96,0.1); }

    #escape-room-container .room-1 .back-wall, #escape-room-container .room-1 .left-wall, #escape-room-container .room-1 .right-wall { background: linear-gradient(180deg,#12121a 0%,#1a1a2e 50%,#0d0d15 100%); }
    #escape-room-container .room-2 .back-wall, #escape-room-container .room-2 .left-wall, #escape-room-container .room-2 .right-wall { background: linear-gradient(180deg,#1a120a 0%,#2e1a0a 50%,#150d05 100%); border-color: #f39c12; }
    #escape-room-container .room-3 .back-wall, #escape-room-container .room-3 .left-wall, #escape-room-container .room-3 .right-wall { background: linear-gradient(180deg,#0a1a12 0%,#0a2e1a 50%,#050d0a 100%); border-color: #2ecc71; }

    #escape-room-container .interactive { cursor: none; transition: all 0.3s ease; pointer-events: all; position: relative; z-index: 250; }
    #escape-room-container .interactive:hover { filter: brightness(1.5) drop-shadow(0 0 25px currentColor); transform: scale(1.05); }

    #escape-room-container .door, #escape-room-container .vent, #escape-room-container .cabinet, #escape-room-container .chest, #escape-room-container .safe, #escape-room-container .lever-container, #escape-room-container .power-box, #escape-room-container .keypad, #escape-room-container .bookshelf, #escape-room-container .note, #escape-room-container .painting { pointer-events: all !important; z-index: 300; }
    #escape-room-container .vent .vent-slat, #escape-room-container .cabinet .cabinet-door { pointer-events: none; }

    #escape-room-container .door { width: 140px; height: 280px; background: linear-gradient(145deg,#2a2a3a,#1a1a25); border: 4px solid #444; position: absolute; left: 50%; bottom: 0; transform: translateX(-50%); border-radius: 8px 8px 0 0; box-shadow: inset 0 0 50px rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; font-size: 50px; z-index: 400; pointer-events: all !important; }
    #escape-room-container .door:hover { filter: brightness(1.3) drop-shadow(0 0 30px #e94560); transform: translateX(-50%) scale(1.02); }
    #escape-room-container .door.locked::after { content: 'üîí'; position: absolute; top: 50%; right: 15px; transform: translateY(-50%); font-size: 24px; }
    #escape-room-container .door.unlocked { border-color: #2ecc71; box-shadow: 0 0 30px rgba(46,204,113,0.5); }
    #escape-room-container .door.unlocked::after { content: 'üîì'; position: absolute; top: 50%; right: 15px; transform: translateY(-50%); font-size: 24px; }
    #escape-room-container .door-back { width: 140px; height: 280px; position: absolute; left: 18%; bottom: 0; transform: translateX(-50%); font-size: 45px; opacity: 0.9; z-index: 400; pointer-events: all !important; border: 4px solid #444; border-radius: 8px 8px 0 0; display: flex; align-items: center; justify-content: center; background: linear-gradient(145deg,#2a2a3a,#1a1a25); box-shadow: inset 0 0 30px rgba(0,0,0,0.6); }
    #escape-room-container .door-back:hover { opacity: 1; transform: translateX(-50%) scale(1.05); }

    #escape-room-container .cabinet { width: 170px; height: 220px; background: linear-gradient(145deg,#4a3a2a,#3a2a1a); border: 4px solid #2d1810; position: absolute; border-radius: 5px; display: flex; flex-direction: column; z-index: 50; pointer-events: all !important; }
    #escape-room-container .cabinet.shelves-open::after { content: 'üîç'; position: absolute; top: -18px; right: -10px; font-size: 20px; }
    #escape-room-container .cabinet-door { flex: 1; background: linear-gradient(145deg,#5a4a3a,#4a3a2a); margin: 5px; border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 25px; border: 2px solid #2d1810; pointer-events: none; }

    #escape-room-container .chest { width: 150px; height: 100px; background: linear-gradient(145deg,#8b4513,#654321); border: 4px solid #4a2a0a; position: absolute; border-radius: 10px 10px 5px 5px; display: flex; align-items: center; justify-content: center; font-size: 35px; z-index: 50; }
    #escape-room-container .chest.locked { box-shadow: 0 0 20px rgba(233,69,96,0.5); animation: escape-glow-pulse 2s infinite; }

    #escape-room-container .note { width: 110px; height: 90px; background: #fffacd; position: absolute; padding: 10px; font-size: 11px; color: #333; box-shadow: 2px 2px 10px rgba(0,0,0,0.3); font-family: 'Comic Sans MS', cursive; line-height: 1.3; transform: rotate(-3deg); z-index: 50; }

    #escape-room-container .bookshelf { width: 250px; height: 300px; background: linear-gradient(145deg,#5c4033,#3d2817); border: 5px solid #2d1810; position: absolute; display: grid; grid-template-rows: repeat(4,1fr); gap: 5px; padding: 10px; z-index: 50; }
    #escape-room-container .shelf-row { display: flex; align-items: flex-end; gap: 3px; padding: 5px; background: rgba(0,0,0,0.3); }
    #escape-room-container .book { height: 70%; min-width: 15px; border-radius: 2px; transition: transform 0.2s; }
    #escape-room-container .book.special { background: linear-gradient(145deg,#e94560,#a03050) !important; box-shadow: 0 0 15px rgba(233,69,96,0.5); animation: escape-glow-pulse 2s infinite; }
    #escape-room-container .book:hover { transform: translateY(-10px); }

    #escape-room-container .painting { width: 180px; height: 130px; background: linear-gradient(145deg,#2a1a1a,#1a1015); border: 8px solid #8b4513; position: absolute; box-shadow: 0 10px 40px rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; font-size: 60px; z-index: 50; }

    #escape-room-container .vent { width: 120px; height: 80px; background: linear-gradient(180deg,#1a1a1a,#0a0a0a); border: 3px solid #444; position: absolute; display: grid; grid-template-columns: repeat(6,1fr); gap: 2px; padding: 5px; border-radius: 5px; box-shadow: inset 0 0 20px rgba(0,0,0,0.8); z-index: 400; pointer-events: all !important; }
    #escape-room-container .vent-slat { background: linear-gradient(180deg,#333,#1a1a1a); border-radius: 2px; }
    #escape-room-container .vent.closed { animation: escape-vent-pulse 2s infinite; }
    #escape-room-container .vent.open { border-color: #2ecc71; box-shadow: 0 0 20px rgba(46,204,113,0.5), inset 0 0 30px rgba(0,0,0,0.5); }
    @keyframes escape-vent-pulse { 0%,100% { box-shadow: 0 0 10px rgba(233,69,96,0.3);} 50% { box-shadow: 0 0 25px rgba(233,69,96,0.6);} }

    #escape-room-container .safe { width: 120px; height: 120px; background: linear-gradient(145deg,#3d3d4a,#2a2a35); border: 5px solid #555; position: absolute; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 40px; z-index: 50; }
    #escape-room-container .safe.locked { box-shadow: 0 0 20px rgba(233,69,96,0.3); animation: escape-glow-pulse 2s infinite; }

    #escape-room-container .lever-container { position: absolute; width: 60px; height: 120px; background: #333; border: 3px solid #555; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 10px; z-index: 50; }
    #escape-room-container .lever { width: 20px; height: 60px; background: linear-gradient(145deg,#888,#666); border-radius: 5px; transition: transform 0.3s; }
    #escape-room-container .lever.pulled { transform: rotate(45deg); background: linear-gradient(145deg,#2ecc71,#27ae60); }

    #escape-room-container .power-box { width: 100px; height: 80px; background: #2a2a2a; border: 3px solid #444; position: absolute; display: flex; align-items: center; justify-content: center; border-radius: 5px; z-index: 50; }
    #escape-room-container .power-box.needs-fuse { animation: escape-vent-pulse 2s infinite; }
    #escape-room-container .power-light { width: 30px; height: 30px; border-radius: 50%; background: #333; border: 2px solid #555; }
    #escape-room-container .power-light.on { background: #2ecc71; box-shadow: 0 0 20px #2ecc71; }

    #escape-room-container .keypad { width: 150px; height: 200px; background: #2a2a3a; border: 4px solid #444; position: absolute; border-radius: 10px; padding: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 50; }
    #escape-room-container .keypad-display { background: #0a0a0f; color: #2ecc71; padding: 10px; text-align: center; font-family: monospace; font-size: 18px; border-radius: 5px; min-height: 40px; }
    #escape-room-container .keypad-buttons { display: grid; grid-template-columns: repeat(3,1fr); gap: 5px; flex: 1; }
    #escape-room-container .keypad-btn { background: #444; border: none; border-radius: 5px; color: white; font-size: 16px; cursor: none; transition: all 0.2s; }
    #escape-room-container .keypad-btn:hover:not(:disabled) { background: #e94560; transform: scale(1.1); }
    #escape-room-container .keypad-btn:disabled { opacity: 0.5; }

    #escape-room-container .escape-floating-item { position: fixed; z-index: 500; cursor: none; display: flex; flex-direction: column; align-items: center; gap: 5px; font-size: 45px; animation: escape-float 3s ease-in-out infinite; pointer-events: all; }
    #escape-room-container .escape-floating-item:hover { transform: scale(1.3); filter: brightness(1.5) drop-shadow(0 0 20px gold); }
    #escape-room-container .escape-floating-item .label { color: white; font-size: 12px; background: rgba(0,0,0,0.9); padding: 5px 12px; border-radius: 10px; border: 1px solid #e94560; }
    @keyframes escape-float { 0%,100% { transform: translateY(0);} 50% { transform: translateY(-10px);} }

    #escape-room-container .orb { width: 50px; height: 50px; border-radius: 50%; box-shadow: 0 0 30px currentColor, inset 0 0 20px rgba(255,255,255,0.3); }
    #escape-room-container .orb-red { background: radial-gradient(circle at 30% 30%, #ff6b6b, #c0392b); color: #ff6b6b; }
    #escape-room-container .orb-blue { background: radial-gradient(circle at 30% 30%, #74b9ff, #0984e3); color: #74b9ff; }
    #escape-room-container .orb-green { background: radial-gradient(circle at 30% 30%, #55efc4, #00b894); color: #55efc4; }

    #escape-room-container .escape-hud { position: fixed; top: 20px; left: 20px; z-index: 100; color: #e94560; text-shadow: 0 0 10px rgba(233,69,96,0.5); }
    #escape-room-container .escape-room-indicator { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(26,26,46,0.9); border: 2px solid #e94560; padding: 10px 30px; border-radius: 25px; color: white; font-size: 18px; z-index: 100; }
    #escape-room-container .escape-compass { position: fixed; top: 100px; left: 20px; width: 70px; height: 70px; background: rgba(26,26,46,0.9); border: 2px solid #e94560; border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 100; }
    #escape-room-container .escape-compass-arrow { font-size: 24px; transition: transform 0.1s; }
    #escape-room-container .escape-direction-label { position: absolute; font-size: 10px; color: #e94560; }
    #escape-room-container .dir-n { top: 5px; } #escape-room-container .dir-s { bottom: 5px; } #escape-room-container .dir-e { right: 5px; } #escape-room-container .dir-w { left: 5px; }

    #escape-room-container .escape-hint-btn { position: fixed; bottom: 20px; right: 20px; z-index: 100; background: linear-gradient(145deg,#e94560,#a03050); color: white; border: none; padding: 15px 30px; border-radius: 50px; font-size: 18px; cursor: none; transition: all 0.3s; box-shadow: 0 5px 20px rgba(233,69,96,0.4); }
    #escape-room-container .escape-hint-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 30px rgba(233,69,96,0.6); }
    #escape-room-container .escape-hint-popup { position: fixed; bottom: 90px; right: 20px; background: rgba(26,26,46,0.95); border: 2px solid #e94560; padding: 20px; border-radius: 15px; color: #fff; max-width: 350px; z-index: 100; display: none; }

    #escape-room-container .escape-inventory { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 100; background: rgba(10,10,15,0.95); padding: 10px 20px; border-radius: 15px; border: 2px solid #e94560; }
    #escape-room-container .escape-inv-slot { width: 55px; height: 55px; background: rgba(26,26,46,0.9); border: 2px solid #444; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 26px; transition: all 0.3s; cursor: none; }
    #escape-room-container .escape-inv-slot.filled { border-color: #e94560; box-shadow: 0 0 15px rgba(233,69,96,0.5); }
    #escape-room-container .escape-inv-slot.selected { border-color: #2ecc71; box-shadow: 0 0 20px rgba(46,204,113,0.8); transform: scale(1.15); }
    #escape-room-container .escape-inv-slot:hover.filled { transform: scale(1.1); }

    #escape-room-container .escape-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 200; }
    #escape-room-container .escape-modal-content { background: linear-gradient(145deg,#1a1a2e,#16213e); border: 3px solid #e94560; border-radius: 20px; padding: 40px; text-align: center; color: white; max-width: 500px; position: relative; }
    #escape-room-container .close-modal { position: absolute; top: 15px; right: 20px; color: #e94560; font-size: 28px; cursor: pointer; }

    /* Wiring modal */
    #escape-room-container .wire-panel { display: flex; gap: 260px; justify-content: center; align-items: center; margin: 32px 0; position: relative; }
    #escape-room-container .wire-column { display: flex; flex-direction: column; gap: 22px; }
    #escape-room-container .wire-node {
        min-width: 190px;
        padding: 12px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        border: 2px solid #555;
        cursor: grab;
        transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
        color: white;
        letter-spacing: 1px;
        position: relative;
        background: rgba(255,255,255,0.04);
        box-shadow: inset 0 0 12px rgba(0,0,0,0.45);
        user-select: none;
    }
    #escape-room-container .wire-node:active { cursor: grabbing; transform: scale(1.03); }
    #escape-room-container .wire-node::before, #escape-room-container .wire-node::after {
        content: '';
        position: absolute;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: currentColor;
        box-shadow: 0 0 12px currentColor;
    }
    #escape-room-container .wire-node[data-side="left"]::before { left: -24px; }
    #escape-room-container .wire-node[data-side="right"]::after { right: -24px; }
    #escape-room-container .wire-node::after { /* tail */
        width: 110px;
        height: 6px;
        border-radius: 999px;
        top: 50%;
        transform: translateY(-50%);
        box-shadow: none;
        background: linear-gradient(90deg, currentColor 0%, rgba(255,255,255,0.5) 50%, currentColor 100%);
        opacity: 0.6;
    }
    #escape-room-container .wire-node[data-side="left"]::after { left: 90%; }
    #escape-room-container .wire-node[data-side="right"]::before { /* hide left ball on right nodes */ display: none; }
    #escape-room-container .wire-node[data-side="right"]::after { right: 90%; transform: translateY(-50%) rotate(180deg); }
    #escape-room-container .wire-node.matched {
        border-color: #2ecc71;
        background: rgba(46,204,113,0.15) !important;
        box-shadow: 0 0 12px rgba(46,204,113,0.8);
    }
    #escape-room-container .wire-drop-target { border-style: dashed; }

    #escape-room-container .escape-particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    #escape-room-container .escape-particle { position: absolute; width: 4px; height: 4px; background: #e94560; border-radius: 50%; animation: escape-particleFloat 15s infinite linear; }
    @keyframes escape-particleFloat { 0% { transform: translateY(100vh) rotate(0deg); opacity: 0;} 10% { opacity: 0.6;} 90% { opacity: 0.6;} 100% { transform: translateY(-100vh) rotate(720deg); opacity: 0;} }

    #escape-room-container .escape-room-label { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); color: rgba(233,69,96,0.6); font-size: 14px; z-index: 100; text-transform: uppercase; letter-spacing: 3px; }
    #escape-room-container .escape-use-item-hint { position: fixed; bottom: 95px; left: 50%; transform: translateX(-50%); background: rgba(46,204,113,0.9); color: white; padding: 8px 20px; border-radius: 20px; font-size: 14px; z-index: 100; display: none; }
    #escape-room-container .escape-transition-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a0f; z-index: 250; display: none; align-items: center; justify-content: center; color: white; font-size: 32px; }
    @keyframes escape-glow-pulse { 0%,100% { filter: brightness(1);} 50% { filter: brightness(1.3) drop-shadow(0 0 15px currentColor);} }
  </style>
</head>
<body>
  <div id="game-container"></div>
  
  <!-- Title Screen -->
  <div id="title-screen">
    <h1>‚ö° AENEAS ‚ö°</h1>
    <h2>Descent to the Underworld</h2>
    <div class="platform-selection">
      <button class="platform-btn active" id="btn-pc">üñ•Ô∏è PC</button>
      <button class="platform-btn" id="btn-mobile">üì± Mobile</button>
    </div>
    <button class="start-btn" id="btn-start">BEGIN JOURNEY</button>
    <p id="controls-hint">Arrow Keys to move ‚Ä¢ WASD to look ‚Ä¢ Space to jump/attack ‚Ä¢ E to interact</p>
  </div>
  
  <!-- Fade Overlay -->
  <div id="fade-overlay"></div>
  
  <!-- Death Flash Overlay -->
  <div id="death-flash-overlay">
    <img src="/images/death-bruh.gif" alt="Bruh">
  </div>
  
  <!-- Narrator Box -->
  <div id="narrator-box">
    <div class="speaker">Your Consciousness</div>
    <div class="text">...</div>
    <div class="tap-hint">Click or tap to continue</div>
  </div>
  
  <!-- Crosshair -->
  <div id="crosshair"></div>
  
  <!-- Inventory -->
  <div id="inventory">
    <div class="inv-slot" id="slot-1"><span class="slot-num">1</span></div>
    <div class="inv-slot" id="slot-2"><span class="slot-num">2</span></div>
    <div class="inv-slot" id="slot-3"><span class="slot-num">3</span></div>
  </div>
  
  <!-- Health Bar -->
  <div id="health-bar">
    <div class="hearts">
      <span class="heart" id="heart-1">‚ù§Ô∏è</span>
      <span class="heart" id="heart-2">‚ù§Ô∏è</span>
      <span class="heart" id="heart-3">‚ù§Ô∏è</span>
    </div>
  </div>
  
  <!-- Body Switch Menu -->
  <div id="body-switch-menu">
    <h2>Switch Body</h2>
    <div class="body-options">
      <div class="body-option" id="body-aeneas">
        <div class="avatar">üèõÔ∏è</div>
        <div class="name">Aeneas</div>
      </div>
      <div class="body-option" id="body-perseus">
        <div class="avatar">‚öîÔ∏è</div>
        <div class="name">Perseus</div>
      </div>
    </div>
  </div>
  
  <!-- Puzzle UI -->
  <div id="puzzle-ui">
    <h3>üîÆ Collect Orbs</h3>
    <div class="orb-count"><span id="orbs-collected">0</span> / 3</div>
  </div>
  
  <!-- Mobile Controls -->
  <div id="mobile-controls">
    <div id="look-area"></div>
    <div id="joystick-zone">
      <div id="move-joystick">
        <div class="joystick-base"></div>
        <div class="joystick-knob" id="joystick-knob"></div>
      </div>
    </div>
    <div id="action-buttons">
      <button class="action-btn" id="btn-interact">üí¨</button>
      <div class="action-row">
        <button class="action-btn" id="btn-jump">‚¨ÜÔ∏è</button>
        <button class="action-btn" id="btn-attack">‚öîÔ∏è</button>
      </div>
      <div class="action-row">
        <button class="action-btn" id="btn-kick">ü¶∂</button>
        <button class="action-btn" id="btn-punch">üëä</button>
      </div>
    </div>
  </div>
  
  <!-- Win Screen (old - replaced by victory-screen) -->
  <div id="win-screen" style="display:none !important;"></div>

  <!-- Player Lives UI -->
  <div id="player-lives">
    <div class="lives-title">‚öîÔ∏è LIVES</div>
    <div class="life-bar-container" id="life-1">
      <span class="life-icon">‚ù§Ô∏è</span>
      <div class="life-bar">
        <div class="life-bar-fill" id="life-fill-1" style="width: 100%;"></div>
      </div>
    </div>
    <div class="life-bar-container" id="life-2">
      <span class="life-icon">‚ù§Ô∏è</span>
      <div class="life-bar">
        <div class="life-bar-fill" id="life-fill-2" style="width: 100%;"></div>
      </div>
    </div>
    <div class="life-bar-container" id="life-3">
      <span class="life-icon">‚ù§Ô∏è</span>
      <div class="life-bar">
        <div class="life-bar-fill" id="life-fill-3" style="width: 100%;"></div>
      </div>
    </div>
  </div>

  <!-- Hades Health Bar -->
  <div id="hades-health-bar">
    <div id="boss-messages" aria-live="polite"></div>
    <div class="boss-name">üíÄ HADES - GOD OF THE UNDERWORLD üíÄ</div>
    <div class="health-bar-outer">
      <div class="health-bar-inner" id="hades-health-fill" style="width: 100%;"></div>
    </div>
    <div class="health-text"><span id="hades-health-text">300</span> / 300</div>
  </div>

  <!-- Portal Password UI -->
  <div id="portal-password-ui">
    <h2>üåÄ THE PORTAL SPEAKS üåÄ</h2>
    <p>"Speak the sacred number to enter<br>the realm of the dead..."</p>
    <input type="text" id="portal-password-input" maxlength="4" placeholder="???" autocomplete="off">
    <div class="portal-btn-row">
      <button class="portal-btn enter" id="portal-submit-btn">‚ö° ENTER ‚ö°</button>
      <button class="portal-btn cancel" id="portal-cancel-btn">‚Üê RETREAT</button>
    </div>
    <div id="portal-error"></div>
  </div>

  <!-- Throne Sit Button -->
  <button id="throne-sit-btn">üëë SIT ON THE THRONE üëë</button>

  <!-- Victory Screen -->
  <div id="victory-screen">
    <h1>YOU WIN</h1>
    <p class="victory-subtitle">You have conquered the Underworld and claimed the throne of Hades.</p>
    <button class="end-btn" id="end-game-btn">END GAME</button>
  </div>

  <!-- ENHANCEMENT: Pause Button -->
  <div id="pause-button">‚è∏Ô∏è</div>

  <!-- ENHANCEMENT: Pause Menu -->
  <div id="pause-menu">
    <div id="pause-content">
      <h2>‚è∏Ô∏è PAUSED</h2>
      
      <div class="pause-section">
        <label for="master-volume">üîä Master Volume: <span id="volume-value">50</span>%</label>
        <input type="range" id="master-volume" class="pause-slider" min="0" max="100" value="50">
      </div>
      
      <div class="pause-section">
        <label for="music-volume">üéµ Music Volume: <span id="music-value">50</span>%</label>
        <input type="range" id="music-volume" class="pause-slider" min="0" max="100" value="50">
      </div>
      
      <div class="pause-section">
        <label for="sfx-volume">üîî Sound Effects: <span id="sfx-value">50</span>%</label>
        <input type="range" id="sfx-volume" class="pause-slider" min="0" max="100" value="50">
      </div>
      
      <div class="pause-section" style="margin-top: 40px;">
        <button class="pause-btn" id="resume-btn">‚ñ∂Ô∏è Resume</button><br>
        <button class="pause-btn danger" id="restart-btn">üîÑ Restart</button>
        <button class="pause-btn danger" id="home-btn">üè† Main Menu</button>
      </div>
    </div>
  </div>

  <!-- ENHANCEMENT: Cerberus Minigame Container -->
  <div id="cerberus-minigame" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:1500;overflow:hidden;display:none;"></div>

  <!-- Escape Room Container -->
  <div id="escape-room-container">
    <div class="custom-cursor" id="escape-cursor"></div>
    <div class="escape-particles" id="escape-particles"></div>
    <div class="escape-transition-overlay" id="escapeTransitionOverlay">Entering next room...</div>

    <div class="escape-game-container" id="escapeGameContainer">
        <div class="room room-1" id="escapeRoom"></div>
    </div>

    <div class="escape-hud">
        <h2 class="text-xl font-bold mb-1">üîÆ PERSEUS'S TRIAL</h2>
        <p class="text-sm opacity-70">Move mouse to look around</p>
        <p class="text-sm opacity-70">Click objects to interact</p>
        <p class="text-sm opacity-70 text-green-400">Click inventory to select item</p>
    </div>

    <div class="escape-room-indicator" id="escapeRoomIndicator">Room 1 of 3</div>

    <div class="escape-compass">
        <span class="escape-direction-label dir-n">N</span>
        <span class="escape-direction-label dir-s">S</span>
        <span class="escape-direction-label dir-e">E</span>
        <span class="escape-direction-label dir-w">W</span>
        <span class="escape-compass-arrow" id="escapeCompassArrow">‚¨ÜÔ∏è</span>
    </div>

    <div class="escape-room-label" id="escapeRoomLabel">Facing: Back Wall</div>

    <div class="escape-inventory" id="escapeInventory">
        <div class="escape-inv-slot" id="escapeSlot0"></div>
        <div class="escape-inv-slot" id="escapeSlot1"></div>
        <div class="escape-inv-slot" id="escapeSlot2"></div>
        <div class="escape-inv-slot" id="escapeSlot3"></div>
        <div class="escape-inv-slot" id="escapeSlot4"></div>
        <div class="escape-inv-slot" id="escapeSlot5"></div>
    </div>

    <div class="escape-use-item-hint" id="escapeUseItemHint">Click on an object to use selected item</div>

    <button class="escape-hint-btn" id="escapeHintBtn">üí° Hint</button>

    <div class="escape-hint-popup" id="escapeHintPopup"><p id="escapeHintText">Loading hint...</p></div>

    <div class="escape-modal" id="escapeNoteModal">
        <div class="escape-modal-content">
            <span class="close-modal" id="closeNoteModal">&times;</span>
            <h3 class="text-2xl mb-4">üìù Note</h3>
            <p id="escapeNoteContent" class="text-lg leading-relaxed"></p>
        </div>
    </div>

    <div class="escape-modal" id="escapeBookModal">
        <div class="escape-modal-content">
            <span class="close-modal" id="closeBookModal">&times;</span>
            <h3 class="text-2xl mb-4">üìñ Ancient Book</h3>
            <p id="escapeBookContent" class="text-lg leading-relaxed"></p>
        </div>
    </div>

    <!-- Wiring Modal -->
    <div class="escape-modal" id="escapeWireModal">
        <div class="escape-modal-content">
            <span class="close-modal" id="closeWireModal">&times;</span>
            <h3 class="text-2xl mb-2">üîß Connect the colored wires</h3>
            <p class="text-sm mb-4">Drag each left wire onto its matching right terminal. Match all three.</p>
            <div class="wire-panel">
                <div class="wire-column left">
                    <div class="wire-node" data-side="left" data-color="blue" draggable="true" style="background:#0a1a2e; color:#74b9ff;">BLUE</div>
                    <div class="wire-node" data-side="left" data-color="red" draggable="true" style="background:#2a1a1a; color:#e74c3c;">RED</div>
                    <div class="wire-node" data-side="left" data-color="green" draggable="true" style="background:#0a1a12; color:#2ecc71;">GREEN</div>
                </div>
                <div class="wire-column right">
                    <div class="wire-node" data-side="right" data-color="green" style="background:#0f4025; color:#2ecc71;">GREEN</div>
                    <div class="wire-node" data-side="right" data-color="red" style="background:#401515; color:#e74c3c;">RED</div>
                    <div class="wire-node" data-side="right" data-color="blue" style="background:#0f2540; color:#74b9ff;">BLUE</div>
                </div>
            </div>
            <p class="text-xs opacity-70 mt-3" id="escapeWireStatus">Drag a left wire to its matching right terminal.</p>
        </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // ============ AUDIO CONTEXT ============
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;

    // WebAudio mixer (fixes mobile volume control limitations)
    let masterGain = null;
    let musicGain = null;
    let sfxGain = null;
    let currentBgSource = null;
    let deathSoundSource = null;

    function ensureAudioMixer() {
      if (!audioCtx) return;
      if (masterGain && musicGain && sfxGain) return;

      masterGain = audioCtx.createGain();
      musicGain = audioCtx.createGain();
      sfxGain = audioCtx.createGain();

      musicGain.connect(masterGain);
      sfxGain.connect(masterGain);
      masterGain.connect(audioCtx.destination);
    }

    function applyVolumes() {
      // Mixer path (preferred, works on iOS)
      if (masterGain) masterGain.gain.value = soundVolume;
      if (musicGain) musicGain.gain.value = musicVolume;
      if (sfxGain) sfxGain.gain.value = sfxVolume;

      // Fallback (non-iOS / if mixer not available)
      if (currentBgAudio && !currentBgSource) {
        currentBgAudio.volume = soundVolume * musicVolume;
      }
      if (deathSound && !deathSoundSource) {
        deathSound.volume = soundVolume * sfxVolume;
      }
    }
    
    function initAudio() {
      if (!audioCtx) audioCtx = new AudioContext();
      ensureAudioMixer();
      // Mobile browsers often start suspended; resume on first user gesture.
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(() => {});
      }
    }
    
    function playSound(type) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      // Route through mixer when available so Master/SFX sliders work everywhere (incl. mobile)
      ensureAudioMixer();
      gain.connect(sfxGain || audioCtx.destination);
      
      switch(type) {
        case 'step':
          osc.frequency.value = 80 + Math.random() * 40;
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, audioCtx.currentTime + 0.1);
          osc.start(); osc.stop(audioCtx.currentTime + 0.1);
          break;
        case 'thunder':
          osc.type = 'sawtooth';
          osc.frequency.value = 60;
          gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
          gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, audioCtx.currentTime + 0.5);
          osc.start(); osc.stop(audioCtx.currentTime + 0.5);
          break;
        case 'hit':
          osc.type = 'square';
          osc.frequency.value = 150;
          gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
          osc.start(); osc.stop(audioCtx.currentTime + 0.15);
          break;
        case 'collect':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(400, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
          gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
          osc.start(); osc.stop(audioCtx.currentTime + 0.2);
          break;
        case 'door':
          osc.type = 'triangle';
          osc.frequency.value = 50;
          gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
          osc.start(); osc.stop(audioCtx.currentTime + 1);
          break;
      }

      applyVolumes();
    }

    // ENHANCEMENT: Background Music & Pause System
    let soundVolume = 0.5;
    let musicVolume = 0.5;
    let sfxVolume = 0.5;
    let currentBgAudio = null;
    let deathSound = null;
    let isPaused = false;
    let skeletonWarriors = [];

    // Audio file paths
    const audioFiles = {
      nature: '/audio/nature-birds.wav',      // Nature zone
      olympus: '/audio/heavenly-music.mp3',   // Staircase and castle
      staircase: '/audio/heavenly-music.mp3', // Staircase
      underworld: '/audio/underworld-ominous.wav', // Underworld (except puzzle/cerberus)
      styx: '/audio/underworld-ominous.wav',  // River Styx
      battle: '/audio/underworld-ominous.wav', // Boss battle uses ominous guitar
      death: '/audio/death-bruh.mp3',         // Death sound
      mortal: '/audio/nature-birds.wav'       // Nature zone default
    };

    // Preload death sound
    function preloadDeathSound() {
      deathSound = new Audio(audioFiles.death);
      deathSound.preload = 'auto';

      // Route through mixer so SFX/Master sliders work on mobile
      if (audioCtx && audioCtx.createMediaElementSource) {
        try {
          ensureAudioMixer();
          deathSoundSource = audioCtx.createMediaElementSource(deathSound);
          deathSoundSource.connect(sfxGain || audioCtx.destination);
          deathSound.volume = 1;
        } catch (e) {
          // Some browsers forbid re-wrapping the same element; fallback to element volume
          deathSoundSource = null;
        }
      }
      applyVolumes();
    }

    function playDeathSound() {
      if (deathSound) {
        deathSound.currentTime = 0;
        if (!deathSoundSource) deathSound.volume = soundVolume * sfxVolume;
        deathSound.play().catch(e => console.log('Death sound failed:', e));
      }
      
      // Flash the death image for 500ms
      const deathFlashOverlay = document.getElementById('death-flash-overlay');
      if (deathFlashOverlay) {
        deathFlashOverlay.classList.add('active');
        setTimeout(() => {
          deathFlashOverlay.classList.remove('active');
        }, 500);
      }
    }

    function playBackgroundSound(sceneType) {
      stopBackgroundSound();
      
      const audioFile = audioFiles[sceneType] || audioFiles.mortal;
      
      currentBgAudio = new Audio(audioFile);
      currentBgAudio.loop = true;

      // On iOS, HTMLAudioElement.volume is effectively ignored.
      // Route through WebAudio mixer when available.
      if (audioCtx && audioCtx.createMediaElementSource) {
        try {
          ensureAudioMixer();
          currentBgSource = audioCtx.createMediaElementSource(currentBgAudio);
          currentBgSource.connect(musicGain || audioCtx.destination);
          currentBgAudio.volume = 1;
        } catch (e) {
          currentBgSource = null;
          currentBgAudio.volume = soundVolume * musicVolume;
        }
      } else {
        currentBgAudio.volume = soundVolume * musicVolume;
      }

      applyVolumes();
      
      if (!isPaused) {
        currentBgAudio.play().catch(e => console.log('Audio play failed:', e));
      }
    }

    function stopBackgroundSound() {
      if (currentBgAudio) {
        currentBgAudio.pause();
        currentBgAudio.currentTime = 0;
        currentBgAudio = null;
      }

      if (currentBgSource) {
        try { currentBgSource.disconnect(); } catch (e) {}
        currentBgSource = null;
      }
    }

    function updateMusicVolume() {
      applyVolumes();
    }

    // Pause menu volume controls
    document.getElementById('master-volume').addEventListener('input', (e) => {
      soundVolume = e.target.value / 100;
      document.getElementById('volume-value').textContent = e.target.value;
      updateMusicVolume();
    });

    document.getElementById('music-volume').addEventListener('input', (e) => {
      musicVolume = e.target.value / 100;
      document.getElementById('music-value').textContent = e.target.value;
      updateMusicVolume();
    });

    document.getElementById('sfx-volume').addEventListener('input', (e) => {
      sfxVolume = e.target.value / 100;
      document.getElementById('sfx-value').textContent = e.target.value;
      applyVolumes();
    });

    // Pause button handler
    document.getElementById('pause-button').addEventListener('click', () => {
      togglePause();
    });

    document.getElementById('resume-btn').addEventListener('click', () => {
      togglePause();
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
      location.reload();
    });

    document.getElementById('home-btn').addEventListener('click', () => {
      location.reload();
    });

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('pause-menu').style.display = isPaused ? 'flex' : 'none';
      
      if (isPaused) {
        if (currentBgAudio) currentBgAudio.pause();
        if (document.pointerLockElement) document.exitPointerLock();
      } else {
        if (currentBgAudio) currentBgAudio.play().catch(e => {});
      }
    }

    // ============ PORTAL PASSWORD UI ============
    let portalPasswordActive = false;
    let savedCanMove = false;
    let savedCanLook = false;

    function showPortalPasswordUI() {
      portalPasswordActive = true;
      savedCanMove = canMove;
      savedCanLook = canLook;
      canMove = false;
      canLook = false;
      
      // Exit pointer lock on PC
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }
      
      const ui = document.getElementById('portal-password-ui');
      const input = document.getElementById('portal-password-input');
      const error = document.getElementById('portal-error');
      
      ui.style.display = 'flex';
      input.value = '';
      error.textContent = '';
      
      // Focus input after a short delay
      setTimeout(() => input.focus(), 100);
    }

    function hidePortalPasswordUI() {
      portalPasswordActive = false;
      canMove = savedCanMove;
      canLook = savedCanLook;
      
      document.getElementById('portal-password-ui').style.display = 'none';
    }

    function submitPortalPassword() {
      const input = document.getElementById('portal-password-input');
      const error = document.getElementById('portal-error');
      const password = input.value.trim();
      
      if (password === "67") {
        hidePortalPasswordUI();
        showNarration("The portal accepts your offering...");
        showNarration("This leads directly to the throne of Hades!");
        setTimeout(() => {
          enterHadesBattle();
          sceneTransitioning = false;
        }, 2000);
      } else {
        error.textContent = "‚ö†Ô∏è The portal rejects you... Incorrect number.";
        input.value = '';
        input.focus();
        
        // Shake animation
        const ui = document.getElementById('portal-password-ui');
        ui.style.animation = 'none';
        ui.offsetHeight; // Trigger reflow
        ui.style.animation = 'shake 0.5s ease-out, portalPulse 2s ease-in-out infinite';
      }
    }

    function cancelPortalPassword() {
      hidePortalPasswordUI();
      sceneTransitioning = false;
      // Push player back slightly
      playerPos.z -= 3;
      showNarration("I step back from the portal...");
    }

    // Portal password event handlers
    document.getElementById('portal-submit-btn').addEventListener('click', submitPortalPassword);
    document.getElementById('portal-cancel-btn').addEventListener('click', cancelPortalPassword);
    
    document.getElementById('portal-password-input').addEventListener('keydown', (e) => {
      if (e.code === 'Enter') {
        e.preventDefault();
        submitPortalPassword();
      } else if (e.code === 'Escape') {
        e.preventDefault();
        cancelPortalPassword();
      }
    });

    // ESC key to pause (but not when password UI is active)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Escape' && gameState === 'playing' && !portalPasswordActive) {
        togglePause();
      }
    });
    
    // ============ THREE.JS SETUP ============
    const container = document.getElementById('game-container');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.7, 0);
    
    // ============ GAME STATE ============
    let gameState = 'title'; // title, playing, cutscene, puzzle, battle, win
    let currentScene = 'mortal'; // mortal, staircase, fortress, olympus, falling, underworld, styx, boat, hades
    let isMobile = false;
    let canMove = false;
    let canLook = true;
    let canOnlyMoveForward = false;
    
    // Player state
    let playerPos = new THREE.Vector3(0, 1.7, 0);
    let playerVel = new THREE.Vector3();
    let yaw = 0, pitch = 0;
    let isGrounded = true;
    let isCrouching = false;
    let isSprinting = false;
    
    // Inventory
    let inventory = [null, null, null];
    let selectedSlot = 0;
    
    // Combat
    let lives = 3;
    let playerCurrentHealth = 100;
    let playerMaxHealth = 100; // Each health bar has 100 health
    let isInBattle = false;
    let lastSkeletonSpawnTime = 0;
    let skeletonSpawnInterval = 5000; // 5 seconds between skeleton spawns
    let hadesHealth = 100;
    let canAttack = true;
    let attackCooldown = 0;
    
    // Puzzle
    let orbsCollected = 0;
    let puzzleOrbs = [];
    let puzzleCoin = null;
    
    // Input
    let keys = {};
    let joystickInput = { x: 0, y: 0 };
    let lookDelta = { x: 0, y: 0 };
    
    // Dialogue
    let dialogueQueue = [];
    let isDialogueOpen = false;
    
    // Scene progression flags
    let zeusMet = false;
    
    // Scene objects
    let sceneObjects = [];
    let interactables = [];
    let enemies = [];
    
    // ============ MATERIALS ============
    const materials = {
      grass: new THREE.MeshStandardMaterial({ color: 0x3a8c3a, roughness: 0.9 }),
      stone: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 }),
      marble: new THREE.MeshStandardMaterial({ color: 0xf5f5f0, roughness: 0.3 }),
      gold: new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8 }),
      wood: new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.8 }),
      water: new THREE.MeshStandardMaterial({ color: 0x1a3a5c, roughness: 0.1, transparent: true, opacity: 0.8 }),
      ghost: new THREE.MeshStandardMaterial({ color: 0x44ff88, transparent: true, opacity: 0.4, emissive: 0x22aa44, emissiveIntensity: 0.5 }),
      dark: new THREE.MeshStandardMaterial({ color: 0x1a1a2a, roughness: 0.9 }),
      red: new THREE.MeshStandardMaterial({ color: 0xaa2222, roughness: 0.6 }),
      cloud: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1, transparent: true, opacity: 0.8 }),
      lightning: new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2 })
    };
    
    // ============ SCENE BUILDERS ============
    function clearScene() {
      sceneObjects.forEach(obj => scene.remove(obj));
      sceneObjects = [];
      interactables = [];
      enemies = [];
      scene.fog = null;
      scene.background = new THREE.Color(0x000000);
    }
    
    function createMortalRealm() {
      clearScene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 20, 100);
      
      // Sun
      const sunLight = new THREE.DirectionalLight(0xfffaf0, 1.5);
      sunLight.position.set(50, 100, 50);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);
      sceneObjects.push(sunLight);
      
      const ambient = new THREE.AmbientLight(0x6688aa, 0.5);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // Ground
      const groundGeo = new THREE.PlaneGeometry(100, 100, 50, 50);
      const positions = groundGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setZ(i, Math.random() * 0.3);
      }
      groundGeo.computeVertexNormals();
      const ground = new THREE.Mesh(groundGeo, materials.grass);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      sceneObjects.push(ground);
      
      // Flowers and plants
      for (let i = 0; i < 200; i++) {
        const flowerGroup = new THREE.Group();
        const colors = [0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff6bff];
        
        // Stem
        const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3 + Math.random() * 0.2, 6);
        const stemMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.y = 0.15;
        flowerGroup.add(stem);
        
        // Petals
        const petalGeo = new THREE.SphereGeometry(0.08, 8, 8);
        const petalMat = new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
        for (let p = 0; p < 5; p++) {
          const petal = new THREE.Mesh(petalGeo, petalMat);
          const angle = (p / 5) * Math.PI * 2;
          petal.position.set(Math.cos(angle) * 0.06, 0.35, Math.sin(angle) * 0.06);
          petal.scale.set(1, 0.5, 1);
          flowerGroup.add(petal);
        }
        
        // Center
        const centerGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const centerMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const center = new THREE.Mesh(centerGeo, centerMat);
        center.position.y = 0.35;
        flowerGroup.add(center);
        
        flowerGroup.position.set(
          (Math.random() - 0.5) * 60,
          0,
          (Math.random() - 0.5) * 60
        );
        scene.add(flowerGroup);
        sceneObjects.push(flowerGroup);
      }
      
      // Trees (avoid staircase area completely)
      for (let i = 0; i < 30; i++) {
        const tree = createTree();
        let x, z;
        let attempts = 0;
        // Keep trying until we find a position away from staircase
        do {
          const angle = Math.random() * Math.PI * 2;
          const dist = 15 + Math.random() * 25;
          x = Math.cos(angle) * dist;
          z = Math.sin(angle) * dist;
          attempts++;
        } while ((z < -10 && Math.abs(x) < 8) && attempts < 50); // Avoid staircase corridor
        
        // Only add tree if it's not in the staircase area
        if (!(z < -10 && Math.abs(x) < 8)) {
          tree.position.set(x, 0, z);
          scene.add(tree);
          sceneObjects.push(tree);
        }
      }
      
      // Invisible barriers
      createBarrier(0, 0, -45, 100, 20, 1);
      createBarrier(0, 0, 45, 100, 20, 1);
      createBarrier(-45, 0, 0, 1, 20, 100);
      createBarrier(45, 0, 0, 1, 20, 100);
      
      // White floating staircase
      const staircase = createFloatingStaircase();
      staircase.position.set(0, 0, -30);
      scene.add(staircase);
      sceneObjects.push(staircase);
      staircase.userData.isStaircase = true;
      interactables.push(staircase);
      // store rise/run on the staircase for collision use
      staircase.userData.stairRise = 0.25;
      staircase.userData.stairRun = 2.2;
      
      // Boss fight portal behind spawn point
      const bossPortal = createBossPortal();
      bossPortal.position.set(0, 0, 20); // Behind spawn, player spawns at z=10 facing the staircase (z=-30)
      scene.add(bossPortal);
      sceneObjects.push(bossPortal);
      bossPortal.userData.isBossPortal = true;
      interactables.push(bossPortal);
      
      playerPos.set(0, 1.7, 10);
      camera.position.copy(playerPos);
      // Face the staircase (toward -Z). The portal is behind at +Z.
      yaw = 0;
      pitch = 0;
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      canMove = true;
      canOnlyMoveForward = false;
    }
    
    function createBossPortal() {
      const group = new THREE.Group();
      
      // Portal ring
      const ringGeo = new THREE.TorusGeometry(2.5, 0.3, 16, 32);
      const ringMat = new THREE.MeshStandardMaterial({
        color: 0x8800ff,
        emissive: 0x4400aa,
        emissiveIntensity: 0.8,
        metalness: 0.5,
        roughness: 0.3
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 3;
      ring.rotation.x = Math.PI / 2;
      group.add(ring);
      
      // Inner swirling portal effect
      const portalGeo = new THREE.CircleGeometry(2.2, 32);
      const portalMat = new THREE.MeshBasicMaterial({
        color: 0xff00ff,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide
      });
      const portal = new THREE.Mesh(portalGeo, portalMat);
      portal.position.y = 3;
      portal.rotation.x = Math.PI / 2;
      group.add(portal);
      
      // Inner glow layer
      const glowGeo = new THREE.CircleGeometry(1.8, 32);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.position.y = 3;
      glow.position.z = 0.05;
      glow.rotation.x = Math.PI / 2;
      group.add(glow);
      
      // Portal light
      const portalLight = new THREE.PointLight(0xff00ff, 2, 15);
      portalLight.position.y = 3;
      group.add(portalLight);
      
      // Stone base pillars
      const pillarMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.8 });
      const pillarGeo = new THREE.CylinderGeometry(0.4, 0.5, 5, 12);
      
      const leftPillar = new THREE.Mesh(pillarGeo, pillarMat);
      leftPillar.position.set(-3, 2.5, 0);
      group.add(leftPillar);
      
      const rightPillar = new THREE.Mesh(pillarGeo, pillarMat);
      rightPillar.position.set(3, 2.5, 0);
      group.add(rightPillar);
      
      // Floating runes around portal
      const runeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
      for (let i = 0; i < 8; i++) {
        const runeGeo = new THREE.BoxGeometry(0.15, 0.3, 0.05);
        const rune = new THREE.Mesh(runeGeo, runeMat);
        const angle = (i / 8) * Math.PI * 2;
        rune.position.set(
          Math.cos(angle) * 3,
          3 + Math.sin(angle * 2) * 0.5,
          Math.sin(angle) * 0.3
        );
        rune.rotation.z = angle;
        group.add(rune);
      }
      
      // Label above portal
      // (text handled via narration when player gets close)
      
      return group;
    }
    
    function createTree() {
      const group = new THREE.Group();
      
      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 4, 12);
      const trunk = new THREE.Mesh(trunkGeo, materials.wood);
      trunk.position.y = 2;
      trunk.castShadow = true;
      group.add(trunk);
      
      // Foliage
      const foliageGeo = new THREE.SphereGeometry(2.5, 16, 16);
      const foliageMat = new THREE.MeshStandardMaterial({ 
        color: 0x228b22 + Math.floor(Math.random() * 0x222222), 
        roughness: 0.9 
      });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.y = 5;
      foliage.castShadow = true;
      group.add(foliage);
      
      return group;
    }
    
    function createFloatingStaircase() {
      const group = new THREE.Group();
      
      // Steps (comfortable rise/run for climbing) - 80 steps total
      const stairRise = 0.15;
      const stairRun = 1.8;
      for (let i = 0; i < 80; i++) {
        const stepGeo = new THREE.BoxGeometry(4, 0.25, 2);
        const step = new THREE.Mesh(stepGeo, materials.marble);
        step.position.set(0, i * stairRise, -i * stairRun);
        step.castShadow = true;
        step.receiveShadow = true;
        group.add(step);
        
        // Glow under step
        const glowGeo = new THREE.PlaneGeometry(3.5, 1.8);
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0xaaddff, 
          transparent: true, 
          opacity: 0.3,
          side: THREE.DoubleSide 
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.set(0, i * stairRise - 0.13, -i * stairRun);
        glow.rotation.x = -Math.PI / 2;
        group.add(glow);
      }
      
      // Visible side railings
      const railMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.3, metalness: 0.5 });
      for (let i = 0; i < 80; i += 5) {
        // Left post
        const postGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 8);
        const leftPost = new THREE.Mesh(postGeo, railMat);
        leftPost.position.set(-1.8, i * stairRise + 0.75, -i * stairRun);
        group.add(leftPost);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeo, railMat);
        rightPost.position.set(1.8, i * stairRise + 0.75, -i * stairRun);
        group.add(rightPost);
      }
      
      return group;
    }
    
    function createBarrier(x, y, z, w, h, d) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
      const barrier = new THREE.Mesh(geo, mat);
      barrier.position.set(x, y + h/2, z);
      barrier.userData.isBarrier = true;
      scene.add(barrier);
      sceneObjects.push(barrier);
    }
    
    // Store fortress elements for animation
    let fortressDoors = { left: null, right: null };
    let fortressGuardians = { left: null, right: null };
    let doorsOpening = false;
    let doorsOpen = false;
    
    function createFortressGates() {
      clearScene();
      scene.background = new THREE.Color(0x6677889);
      scene.fog = new THREE.FogExp2(0x667788, 0.015);
      
      // Dramatic lighting
      const ambient = new THREE.AmbientLight(0x8899bb, 0.4);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      const sunLight = new THREE.DirectionalLight(0xffeedd, 1.2);
      sunLight.position.set(-30, 80, 50);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);
      sceneObjects.push(sunLight);
      
      // Rim light from behind fortress
      const rimLight = new THREE.DirectionalLight(0xaaccff, 0.5);
      rimLight.position.set(0, 30, -50);
      scene.add(rimLight);
      sceneObjects.push(rimLight);
      
      // Dense clouds below
      for (let i = 0; i < 80; i++) {
        const cloudGroup = new THREE.Group();
        const cloudMat = new THREE.MeshStandardMaterial({ 
          color: 0xddeeff, 
          roughness: 1, 
          transparent: true, 
          opacity: 0.85 
        });
        for (let j = 0; j < 6; j++) {
          const puffGeo = new THREE.SphereGeometry(4 + Math.random() * 8, 16, 16);
          const puff = new THREE.Mesh(puffGeo, cloudMat);
          puff.position.set((Math.random() - 0.5) * 15, Math.random() * 4, (Math.random() - 0.5) * 10);
          cloudGroup.add(puff);
        }
        cloudGroup.position.set(
          (Math.random() - 0.5) * 250,
          -25 + Math.random() * 8,
          (Math.random() - 0.5) * 250
        );
        scene.add(cloudGroup);
        sceneObjects.push(cloudGroup);
      }
      
      // ===== FORTRESS STRUCTURE =====
      const fortressGroup = new THREE.Group();
      
      // Stone material with texture-like variation
      const stoneMat = new THREE.MeshStandardMaterial({ 
        color: 0x8888990, 
        roughness: 0.85, 
        metalness: 0.1 
      });
      const darkStoneMat = new THREE.MeshStandardMaterial({ 
        color: 0x556677, 
        roughness: 0.9 
      });
      const bronzeMat = new THREE.MeshStandardMaterial({ 
        color: 0xcd7f32, 
        roughness: 0.3, 
        metalness: 0.8 
      });
      
      // Main fortress wall (behind the gate)
      const wallGeo = new THREE.BoxGeometry(80, 40, 8);
      const mainWall = new THREE.Mesh(wallGeo, stoneMat);
      mainWall.position.set(0, 20, -8);
      mainWall.castShadow = true;
      mainWall.receiveShadow = true;
      fortressGroup.add(mainWall);
      
      // Left tower
      const towerGeo = new THREE.CylinderGeometry(8, 9, 55, 24);
      const leftTower = new THREE.Mesh(towerGeo, stoneMat);
      leftTower.position.set(-35, 27.5, 0);
      leftTower.castShadow = true;
      fortressGroup.add(leftTower);
      
      // Left tower roof (conical)
      const roofGeo = new THREE.ConeGeometry(10, 12, 24);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.7 });
      const leftRoof = new THREE.Mesh(roofGeo, roofMat);
      leftRoof.position.set(-35, 60, 0);
      fortressGroup.add(leftRoof);
      
      // Right tower
      const rightTower = new THREE.Mesh(towerGeo, stoneMat);
      rightTower.position.set(35, 27.5, 0);
      rightTower.castShadow = true;
      fortressGroup.add(rightTower);
      
      const rightRoof = new THREE.Mesh(roofGeo, roofMat);
      rightRoof.position.set(35, 60, 0);
      fortressGroup.add(rightRoof);
      
      // Gate pillars (massive stone columns)
      const pillarGeo = new THREE.CylinderGeometry(3, 3.5, 35, 20);
      const leftPillar = new THREE.Mesh(pillarGeo, stoneMat);
      leftPillar.position.set(-10, 17.5, 4);
      leftPillar.castShadow = true;
      fortressGroup.add(leftPillar);
      
      const rightPillar = new THREE.Mesh(pillarGeo, stoneMat);
      rightPillar.position.set(10, 17.5, 4);
      rightPillar.castShadow = true;
      fortressGroup.add(rightPillar);
      
      // Pillar capitals (decorative tops)
      const capitalGeo = new THREE.CylinderGeometry(4, 3, 3, 20);
      const leftCapital = new THREE.Mesh(capitalGeo, bronzeMat);
      leftCapital.position.set(-10, 36, 4);
      fortressGroup.add(leftCapital);
      
      const rightCapital = new THREE.Mesh(capitalGeo, bronzeMat);
      rightCapital.position.set(10, 36, 4);
      fortressGroup.add(rightCapital);
      
      // Gate arch (curved top)
      const archGroup = new THREE.Group();
      const archMat = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.7 });
      
      // Main arch beam
      const archBeamGeo = new THREE.BoxGeometry(24, 5, 6);
      const archBeam = new THREE.Mesh(archBeamGeo, archMat);
      archBeam.position.set(0, 37, 2);
      archGroup.add(archBeam);
      
      // Decorative arch stones
      for (let i = 0; i < 7; i++) {
        const keystoneGeo = new THREE.BoxGeometry(3, 6, 5);
        const keystone = new THREE.Mesh(keystoneGeo, darkStoneMat);
        keystone.position.set(-9 + i * 3, 37, 5);
        archGroup.add(keystone);
      }
      
      // Central keystone (larger, decorated)
      const centralKeystoneGeo = new THREE.BoxGeometry(4, 8, 6);
      const centralKeystone = new THREE.Mesh(centralKeystoneGeo, bronzeMat);
      centralKeystone.position.set(0, 38, 5.5);
      archGroup.add(centralKeystone);
      
      // Zeus emblem on keystone
      const emblemGeo = new THREE.CircleGeometry(1.5, 24);
      const emblemMat = new THREE.MeshStandardMaterial({ 
        color: 0xffd700, 
        metalness: 0.9, 
        roughness: 0.2,
        emissive: 0x886600,
        emissiveIntensity: 0.3
      });
      const emblem = new THREE.Mesh(emblemGeo, emblemMat);
      emblem.position.set(0, 38, 8.6);
      archGroup.add(emblem);
      
      fortressGroup.add(archGroup);
      
      // Battlements on top of wall
      for (let i = -8; i <= 8; i++) {
        const merlonGeo = new THREE.BoxGeometry(3, 4, 3);
        const merlon = new THREE.Mesh(merlonGeo, stoneMat);
        merlon.position.set(i * 4.5, 42, -8);
        fortressGroup.add(merlon);
      }
      
      // ===== DOUBLE DOORS =====
      const doorMat = new THREE.MeshStandardMaterial({ 
        color: 0x3a2a1a, 
        roughness: 0.6,
        metalness: 0.2
      });
      
      // Left door
      const doorGeo = new THREE.BoxGeometry(8, 30, 1.5);
      const leftDoor = new THREE.Mesh(doorGeo, doorMat);
      leftDoor.position.set(-4, 15, 2);
      // Set pivot point at the left edge for hinge rotation
      leftDoor.geometry.translate(4, 0, 0);
      leftDoor.position.x = -8;
      fortressGroup.add(leftDoor);
      fortressDoors.left = leftDoor;
      
      // Right door
      const rightDoor = new THREE.Mesh(doorGeo, doorMat);
      rightDoor.position.set(4, 15, 2);
      // Set pivot point at the right edge for hinge rotation
      rightDoor.geometry.translate(-4, 0, 0);
      rightDoor.position.x = 8;
      fortressGroup.add(rightDoor);
      fortressDoors.right = rightDoor;
      
      // Door decorations (bronze studs)
      [-1, 1].forEach(side => {
        for (let row = 0; row < 5; row++) {
          for (let col = 0; col < 2; col++) {
            const studGeo = new THREE.SphereGeometry(0.3, 12, 12);
            const stud = new THREE.Mesh(studGeo, bronzeMat);
            stud.position.set(side * (2 + col * 2.5), 5 + row * 5, 3);
            fortressGroup.add(stud);
          }
        }
        
        // Door ring handles
        const ringGeo = new THREE.TorusGeometry(0.8, 0.15, 12, 24);
        const ring = new THREE.Mesh(ringGeo, bronzeMat);
        ring.position.set(side * 2, 15, 3.5);
        ring.rotation.x = Math.PI / 2;
        fortressGroup.add(ring);
      });
      
      // ===== GUARDIANS (more detailed) =====
      const guardianLeft = createDetailedGuardian();
      guardianLeft.position.set(-6, 0, 8);
      guardianLeft.rotation.y = 0.2;
      fortressGroup.add(guardianLeft);
      fortressGuardians.left = guardianLeft;
      
      const guardianRight = createDetailedGuardian();
      guardianRight.position.set(6, 0, 8);
      guardianRight.rotation.y = -0.2;
      fortressGroup.add(guardianRight);
      fortressGuardians.right = guardianRight;
      
      // ===== TORCHES =====
      [-12, 12].forEach(x => {
        const torchGroup = new THREE.Group();
        
        // Bracket
        const bracketGeo = new THREE.BoxGeometry(0.3, 1.5, 0.8);
        const bracket = new THREE.Mesh(bracketGeo, bronzeMat);
        bracket.position.set(0, 0, 0.4);
        torchGroup.add(bracket);
        
        // Torch holder
        const holderGeo = new THREE.CylinderGeometry(0.2, 0.25, 1, 12);
        const holder = new THREE.Mesh(holderGeo, new THREE.MeshStandardMaterial({ color: 0x4a3020 }));
        holder.position.set(0, 0.3, 0.8);
        holder.rotation.x = -0.3;
        torchGroup.add(holder);
        
        // Flame light
        const fireLight = new THREE.PointLight(0xff6622, 1.5, 15);
        fireLight.position.set(0, 1, 1);
        torchGroup.add(fireLight);
        
        // Flame mesh
        const flameGeo = new THREE.ConeGeometry(0.25, 0.8, 8);
        const flameMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
        const flame = new THREE.Mesh(flameGeo, flameMat);
        flame.position.set(0, 1, 1);
        torchGroup.add(flame);
        
        torchGroup.position.set(x, 18, 4);
        fortressGroup.add(torchGroup);
      });
      
      fortressGroup.position.set(0, 0, -30);
      scene.add(fortressGroup);
      sceneObjects.push(fortressGroup);
      
      // ===== WALKWAY/BRIDGE =====
      const bridgeGeo = new THREE.BoxGeometry(12, 1, 50);
      const bridgeMat = new THREE.MeshStandardMaterial({ color: 0xccccbb, roughness: 0.7 });
      const bridge = new THREE.Mesh(bridgeGeo, bridgeMat);
      bridge.position.set(0, -0.5, 0);
      bridge.receiveShadow = true;
      scene.add(bridge);
      sceneObjects.push(bridge);
      
      // Bridge railings
      [-5.5, 5.5].forEach(x => {
        for (let z = -20; z <= 20; z += 4) {
          const postGeo = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
          const post = new THREE.Mesh(postGeo, stoneMat);
          post.position.set(x, 1, z);
          scene.add(post);
          sceneObjects.push(post);
        }
        
        // Rail bar
        const railGeo = new THREE.BoxGeometry(0.2, 0.15, 42);
        const rail = new THREE.Mesh(railGeo, bronzeMat);
        rail.position.set(x, 2, 0);
        scene.add(rail);
        sceneObjects.push(rail);
      });
      
      // Reset door state
      doorsOpening = false;
      doorsOpen = false;
      
      playerPos.set(0, 1.7, 20);
      camera.position.copy(playerPos);
      yaw = Math.PI;
      canMove = true;
    }
    
    function createDetailedGuardian() {
      const group = new THREE.Group();
      
      const armorMat = new THREE.MeshStandardMaterial({ 
        color: 0xaabbcc, 
        metalness: 0.85, 
        roughness: 0.25 
      });
      const goldMat = new THREE.MeshStandardMaterial({ 
        color: 0xffd700, 
        metalness: 0.9, 
        roughness: 0.2 
      });
      const skinMat = new THREE.MeshStandardMaterial({ 
        color: 0xc4a882, 
        roughness: 0.7 
      });
      const cloakMat = new THREE.MeshStandardMaterial({ 
        color: 0x882222, 
        roughness: 0.8 
      });
      
      // Legs (armored greaves)
      const legGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.8, 12);
      const leftLeg = new THREE.Mesh(legGeo, armorMat);
      leftLeg.position.set(-0.3, 0.9, 0);
      group.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeo, armorMat);
      rightLeg.position.set(0.3, 0.9, 0);
      group.add(rightLeg);
      
      // Feet
      const footGeo = new THREE.BoxGeometry(0.35, 0.2, 0.5);
      const leftFoot = new THREE.Mesh(footGeo, armorMat);
      leftFoot.position.set(-0.3, 0.1, 0.1);
      group.add(leftFoot);
      
      const rightFoot = new THREE.Mesh(footGeo, armorMat);
      rightFoot.position.set(0.3, 0.1, 0.1);
      group.add(rightFoot);
      
      // Torso (muscular breastplate)
      const torsoGeo = new THREE.CylinderGeometry(0.5, 0.45, 1.4, 16);
      const torso = new THREE.Mesh(torsoGeo, armorMat);
      torso.position.y = 2.5;
      group.add(torso);
      
      // Chest detail (muscle lines)
      const chestDetailGeo = new THREE.BoxGeometry(0.6, 0.8, 0.2);
      const chestDetail = new THREE.Mesh(chestDetailGeo, new THREE.MeshStandardMaterial({ 
        color: 0x99aabb, metalness: 0.9, roughness: 0.2 
      }));
      chestDetail.position.set(0, 2.6, 0.35);
      group.add(chestDetail);
      
      // Shoulders (pauldrons)
      const shoulderGeo = new THREE.SphereGeometry(0.35, 16, 16);
      const leftShoulder = new THREE.Mesh(shoulderGeo, armorMat);
      leftShoulder.position.set(-0.65, 3, 0);
      leftShoulder.scale.set(1, 0.8, 1);
      group.add(leftShoulder);
      
      const rightShoulder = new THREE.Mesh(shoulderGeo, armorMat);
      rightShoulder.position.set(0.65, 3, 0);
      rightShoulder.scale.set(1, 0.8, 1);
      group.add(rightShoulder);
      
      // Arms
      const armGeo = new THREE.CylinderGeometry(0.15, 0.18, 1.2, 10);
      const leftArm = new THREE.Mesh(armGeo, armorMat);
      leftArm.position.set(-0.7, 2.2, 0);
      leftArm.rotation.z = 0.15;
      group.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeo, armorMat);
      rightArm.position.set(0.7, 2.2, 0);
      rightArm.rotation.z = -0.15;
      group.add(rightArm);
      
      // Neck
      const neckGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.3, 12);
      const neck = new THREE.Mesh(neckGeo, skinMat);
      neck.position.y = 3.35;
      group.add(neck);
      
      // Head
      const headGeo = new THREE.SphereGeometry(0.4, 20, 20);
      const head = new THREE.Mesh(headGeo, skinMat);
      head.position.y = 3.8;
      head.scale.set(0.9, 1, 0.85);
      group.add(head);
      
      // Helmet (Corinthian style)
      const helmetGroup = new THREE.Group();
      
      // Helmet dome
      const helmetGeo = new THREE.SphereGeometry(0.45, 20, 20, 0, Math.PI * 2, 0, Math.PI * 0.6);
      const helmet = new THREE.Mesh(helmetGeo, goldMat);
      helmet.position.y = 3.9;
      helmetGroup.add(helmet);
      
      // Helmet crest/plume
      const plumeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.8);
      const plumeMat = new THREE.MeshStandardMaterial({ color: 0xcc2222 });
      const plume = new THREE.Mesh(plumeGeo, plumeMat);
      plume.position.set(0, 4.4, 0);
      helmetGroup.add(plume);
      
      // Face guard (cheek pieces)
      const cheekGeo = new THREE.BoxGeometry(0.12, 0.5, 0.25);
      const leftCheek = new THREE.Mesh(cheekGeo, goldMat);
      leftCheek.position.set(-0.35, 3.65, 0.2);
      helmetGroup.add(leftCheek);
      
      const rightCheek = new THREE.Mesh(cheekGeo, goldMat);
      rightCheek.position.set(0.35, 3.65, 0.2);
      helmetGroup.add(rightCheek);
      
      // Nose guard
      const noseGuardGeo = new THREE.BoxGeometry(0.08, 0.4, 0.15);
      const noseGuard = new THREE.Mesh(noseGuardGeo, goldMat);
      noseGuard.position.set(0, 3.7, 0.35);
      helmetGroup.add(noseGuard);
      
      group.add(helmetGroup);
      
      // Eyes (glowing)
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
      const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.12, 3.75, 0.35);
      group.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(0.12, 3.75, 0.35);
      group.add(rightEye);
      
      // Cape
      const capeGeo = new THREE.PlaneGeometry(1.2, 2);
      const cape = new THREE.Mesh(capeGeo, cloakMat);
      cape.position.set(0, 2, -0.4);
      cape.rotation.x = 0.1;
      group.add(cape);
      
      // Staff (held diagonally)
      const staffGroup = new THREE.Group();
      
      const staffShaftGeo = new THREE.CylinderGeometry(0.06, 0.08, 4.5, 12);
      const staffShaftMat = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.7 });
      const staffShaft = new THREE.Mesh(staffShaftGeo, staffShaftMat);
      staffShaft.position.y = 2.25;
      staffGroup.add(staffShaft);
      
      // Staff head (ornate)
      const staffHeadGeo = new THREE.OctahedronGeometry(0.25, 0);
      const staffHead = new THREE.Mesh(staffHeadGeo, goldMat);
      staffHead.position.y = 4.6;
      staffGroup.add(staffHead);
      
      // Staff glow
      const staffLight = new THREE.PointLight(0xffdd88, 0.5, 3);
      staffLight.position.y = 4.6;
      staffGroup.add(staffLight);
      
      staffGroup.position.set(0.5, 0, 0.4);
      staffGroup.rotation.z = -0.5; // Diagonal position (will animate)
      staffGroup.rotation.x = 0.3;
      group.add(staffGroup);
      group.userData.staff = staffGroup;
      
      return group;
    }
    
    // createGuardian is now replaced by createDetailedGuardian in createFortressGates
    
    function createOlympusThrone() {
      clearScene();
      scene.background = new THREE.Color(0xffffff);
      
      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // Cloud floor
      for (let i = 0; i < 100; i++) {
        const cloudGeo = new THREE.SphereGeometry(2 + Math.random() * 3, 12, 12);
        const cloud = new THREE.Mesh(cloudGeo, materials.cloud);
        cloud.position.set(
          (Math.random() - 0.5) * 60,
          -1 + Math.random() * 1,
          (Math.random() - 0.5) * 60
        );
        scene.add(cloud);
        sceneObjects.push(cloud);
      }
      
      // Giant pillars
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const pillar = createGreekPillar(200);
        pillar.position.set(Math.cos(angle) * 25, 0, Math.sin(angle) * 25);
        scene.add(pillar);
        sceneObjects.push(pillar);
      }
      
      // Fog at top of pillars
      const fogGeo = new THREE.PlaneGeometry(100, 100);
      const fogMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      const fog = new THREE.Mesh(fogGeo, fogMat);
      fog.position.y = 50;
      fog.rotation.x = Math.PI / 2;
      scene.add(fog);
      sceneObjects.push(fog);
      
      // Red carpet
      const carpetGeo = new THREE.PlaneGeometry(4, 80);
      const carpetMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.9 });
      const carpet = new THREE.Mesh(carpetGeo, carpetMat);
      carpet.rotation.x = -Math.PI / 2;
      carpet.position.set(0, 0.01, -20);
      scene.add(carpet);
      sceneObjects.push(carpet);
      
      // Zeus throne (massive)
      const throne = createZeusThrone();
      throne.position.set(0, 0, -50);
      scene.add(throne);
      sceneObjects.push(throne);
      
      playerPos.set(0, 1.7, 20);
      camera.position.copy(playerPos);
      yaw = Math.PI;
      canMove = true;
      canOnlyMoveForward = false; // allow full movement in Olympus
    }
    
    function createGreekPillar(height) {
      const group = new THREE.Group();
      
      const baseGeo = new THREE.CylinderGeometry(3, 3.5, 2, 20);
      const base = new THREE.Mesh(baseGeo, materials.marble);
      base.position.y = 1;
      group.add(base);
      
      const shaftGeo = new THREE.CylinderGeometry(2.5, 2.8, height, 24);
      const shaft = new THREE.Mesh(shaftGeo, materials.marble);
      shaft.position.y = height / 2 + 2;
      group.add(shaft);
      
      const capitalGeo = new THREE.CylinderGeometry(3.5, 2.5, 3, 20);
      const capital = new THREE.Mesh(capitalGeo, materials.marble);
      capital.position.y = height + 3.5;
      group.add(capital);
      
      return group;
    }
    
    function createZeusThrone() {
      const group = new THREE.Group();
      
      // Massive throne base
      const baseGeo = new THREE.BoxGeometry(20, 8, 15);
      const base = new THREE.Mesh(baseGeo, materials.marble);
      base.position.y = 4;
      group.add(base);
      
      // Back
      const backGeo = new THREE.BoxGeometry(20, 100, 3);
      const back = new THREE.Mesh(backGeo, materials.marble);
      back.position.set(0, 58, -6);
      group.add(back);
      
      // Zeus figure (gigantic, head hidden in clouds)
      const zeusBody = new THREE.Group();
      
      // Legs
      const legGeo = new THREE.CylinderGeometry(3, 2.5, 25, 16);
      const legMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 });
      const leftLeg = new THREE.Mesh(legGeo, legMat);
      leftLeg.position.set(-5, 20, 5);
      zeusBody.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeo, legMat);
      rightLeg.position.set(5, 20, 5);
      zeusBody.add(rightLeg);
      
      // Torso
      const torsoGeo = new THREE.CylinderGeometry(6, 5, 30, 20);
      const torso = new THREE.Mesh(torsoGeo, legMat);
      torso.position.y = 47;
      zeusBody.add(torso);
      
      // Arms resting
      const armGeo = new THREE.CapsuleGeometry(2, 20, 12, 16);
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xe8c8a8, roughness: 0.7 });
      
      const leftArm = new THREE.Mesh(armGeo, skinMat);
      leftArm.position.set(-10, 40, 3);
      leftArm.rotation.z = 0.8;
      zeusBody.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeo, skinMat);
      rightArm.position.set(10, 40, 3);
      rightArm.rotation.z = -0.8;
      zeusBody.add(rightArm);
      
      // Body disappears into fog
      zeusBody.userData.isZeus = true;
      group.add(zeusBody);
      
      return group;
    }
    
    function createUnderworld() {
      clearScene();
      scene.background = new THREE.Color(0x0a0a15);
      scene.fog = new THREE.FogExp2(0x0a0a15, 0.03);
      
      const ambient = new THREE.AmbientLight(0x334455, 0.4);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // Eerie green light
      const eerieLight = new THREE.PointLight(0x44ff88, 1, 50);
      eerieLight.position.set(0, 10, 0);
      scene.add(eerieLight);
      sceneObjects.push(eerieLight);
      
      // Ground
      const groundGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a25, roughness: 0.95 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      sceneObjects.push(ground);
      
      // Dead souls (ghosts)
      for (let i = 0; i < 140; i++) {
        const ghost = createGhost();
        ghost.position.set(
          (Math.random() - 0.5) * 90,
          0,
          (Math.random() - 0.5) * 90
        );
        ghost.rotation.y = Math.random() * Math.PI * 2;
        ghost.userData.isGhost = true;
        ghost.userData.wanderAngle = Math.random() * Math.PI * 2;
        scene.add(ghost);
        sceneObjects.push(ghost);
      }
      
      // Distant crowd of souls for depth
      for (let i = 0; i < 60; i++) {
        const ghost = createGhost();
        ghost.position.set(
          (Math.random() - 0.5) * 160,
          0,
          -80 - Math.random() * 120
        );
        ghost.scale.setScalar(0.8 + Math.random() * 0.5);
        ghost.userData.isGhost = true;
        scene.add(ghost);
        sceneObjects.push(ghost);
      }
      
      // Special ghosts (Medusa, Hercules)
      const medusa = createMedusa();
      medusa.position.set(15, 0, -10);
      scene.add(medusa);
      sceneObjects.push(medusa);
      
      const hercules = createHercules();
      hercules.position.set(-20, 5, -25);
      scene.add(hercules);
      sceneObjects.push(hercules);
      
      // Priestess
      const priestess = createPriestess();
      priestess.position.set(0, 0, 5);
      priestess.userData.isPriestess = true;
      priestess.userData.name = 'Priestess';
      scene.add(priestess);
      sceneObjects.push(priestess);
      interactables.push(priestess);
      
      playerPos.set(0, 0.5, 10);
      camera.position.copy(playerPos);
      canMove = false; // Will be enabled after dialogue
    }
    
    function createGhost() {
      const group = new THREE.Group();
      
      const spiritMat = new THREE.MeshStandardMaterial({
        color: 0x55ff99,
        transparent: true,
        opacity: 0.45,
        emissive: 0x228855,
        emissiveIntensity: 0.35
      });
      const softMat = new THREE.MeshStandardMaterial({
        color: 0x66ffbb,
        transparent: true,
        opacity: 0.28,
        emissive: 0x227755,
        emissiveIntensity: 0.2
      });
      
      // Torso
      const torsoGeo = new THREE.CapsuleGeometry(0.35, 0.9, 16, 24);
      const torso = new THREE.Mesh(torsoGeo, spiritMat);
      torso.position.y = 1.35;
      group.add(torso);
      
      // Shoulders
      const shoulderGeo = new THREE.SphereGeometry(0.22, 16, 16);
      const leftShoulder = new THREE.Mesh(shoulderGeo, spiritMat);
      leftShoulder.position.set(-0.3, 1.75, 0.05);
      group.add(leftShoulder);
      const rightShoulder = new THREE.Mesh(shoulderGeo, spiritMat);
      rightShoulder.position.set(0.3, 1.75, 0.05);
      group.add(rightShoulder);
      
      // Arms
      const armGeo = new THREE.CapsuleGeometry(0.12, 0.6, 12, 16);
      const leftArm = new THREE.Mesh(armGeo, spiritMat);
      leftArm.position.set(-0.45, 1.25, 0.05);
      leftArm.rotation.z = 0.4;
      group.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo, spiritMat);
      rightArm.position.set(0.45, 1.25, 0.05);
      rightArm.rotation.z = -0.4;
      group.add(rightArm);
      
      // Head + facial glow
      const headGeo = new THREE.SphereGeometry(0.32, 20, 20);
      const head = new THREE.Mesh(headGeo, spiritMat);
      head.position.y = 2.1;
      group.add(head);
      
      const faceGeo = new THREE.SphereGeometry(0.18, 16, 16);
      const face = new THREE.Mesh(faceGeo, softMat);
      face.position.set(0, 2.08, 0.22);
      group.add(face);
      
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xb2ffd8 });
      const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.08, 2.12, 0.28);
      group.add(leftEye);
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(0.08, 2.12, 0.28);
      group.add(rightEye);
      
      // Wispy lower body
      const tailGeo = new THREE.ConeGeometry(0.55, 1.4, 18);
      const tail = new THREE.Mesh(tailGeo, softMat);
      tail.position.y = 0.4;
      tail.rotation.x = Math.PI;
      group.add(tail);
      
      return group;
    }
    
    function createMedusa() {
      const group = new THREE.Group();
      
      // Body
      const bodyGeo = new THREE.CapsuleGeometry(0.5, 1.5, 12, 16);
      const body = new THREE.Mesh(bodyGeo, materials.ghost);
      body.position.y = 1.5;
      group.add(body);
      
      // Head
      const headGeo = new THREE.SphereGeometry(0.45, 16, 16);
      const head = new THREE.Mesh(headGeo, materials.ghost);
      head.position.y = 2.8;
      group.add(head);
      
      // Snakes
      for (let i = 0; i < 12; i++) {
        const snakeGeo = new THREE.CapsuleGeometry(0.05, 0.4, 6, 8);
        const snakeMat = new THREE.MeshStandardMaterial({ 
          color: 0x22aa44, 
          transparent: true, 
          opacity: 0.6 
        });
        const snake = new THREE.Mesh(snakeGeo, snakeMat);
        const angle = (i / 12) * Math.PI * 2;
        snake.position.set(
          Math.cos(angle) * 0.35,
          3.1,
          Math.sin(angle) * 0.35
        );
        snake.rotation.z = (Math.random() - 0.5) * 0.5;
        group.add(snake);
      }
      
      return group;
    }
    
    function createHercules() {
      const group = new THREE.Group();
      
      // Muscular body
      const bodyGeo = new THREE.CapsuleGeometry(0.7, 2, 12, 16);
      const body = new THREE.Mesh(bodyGeo, materials.ghost);
      body.position.y = 2;
      group.add(body);
      
      // Head
      const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const head = new THREE.Mesh(headGeo, materials.ghost);
      head.position.y = 3.8;
      group.add(head);
      
      // Arms
      const armGeo = new THREE.CapsuleGeometry(0.25, 1, 8, 12);
      const leftArm = new THREE.Mesh(armGeo, materials.ghost);
      leftArm.position.set(-1, 2.5, 0);
      leftArm.rotation.z = 0.5;
      group.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeo, materials.ghost);
      rightArm.position.set(1, 2.5, 0);
      rightArm.rotation.z = -0.5;
      group.add(rightArm);
      
      return group;
    }
    
    function createPriestess() {
      const group = new THREE.Group();
      
      const robeMat = new THREE.MeshStandardMaterial({
        color: 0xcfe8ff,
        transparent: true,
        opacity: 0.85,
        emissive: 0x88baff,
        emissiveIntensity: 0.35,
        roughness: 0.3
      });
      const veilMat = new THREE.MeshStandardMaterial({
        color: 0xb5d8ff,
        transparent: true,
        opacity: 0.6,
        emissive: 0x6aa6ff,
        emissiveIntensity: 0.25
      });
      const skinMat = new THREE.MeshStandardMaterial({
        color: 0xe9d7c5,
        roughness: 0.5
      });
      const goldMat = new THREE.MeshStandardMaterial({
        color: 0xffd58a,
        metalness: 0.7,
        roughness: 0.25
      });
      
      // Flowing robe
      const robeGeo = new THREE.ConeGeometry(0.95, 3.4, 24, 6, true);
      const robe = new THREE.Mesh(robeGeo, robeMat);
      robe.position.y = 1.6;
      group.add(robe);
      
      // Inner gown
      const innerGeo = new THREE.CylinderGeometry(0.35, 0.6, 2.2, 16, 1, true);
      const inner = new THREE.Mesh(innerGeo, veilMat);
      inner.position.y = 1.7;
      group.add(inner);
      
      // Shoulders and arms
      const shoulderGeo = new THREE.SphereGeometry(0.22, 16, 16);
      const leftShoulder = new THREE.Mesh(shoulderGeo, robeMat);
      leftShoulder.position.set(-0.35, 2.6, 0.05);
      group.add(leftShoulder);
      const rightShoulder = new THREE.Mesh(shoulderGeo, robeMat);
      rightShoulder.position.set(0.35, 2.6, 0.05);
      group.add(rightShoulder);
      
      const armGeo = new THREE.CapsuleGeometry(0.12, 0.7, 10, 16);
      const leftArm = new THREE.Mesh(armGeo, veilMat);
      leftArm.position.set(-0.55, 2.1, 0.1);
      leftArm.rotation.z = 0.45;
      group.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo, veilMat);
      rightArm.position.set(0.55, 2.1, 0.1);
      rightArm.rotation.z = -0.45;
      group.add(rightArm);
      
      // Head and hair
      const headGeo = new THREE.SphereGeometry(0.36, 20, 20);
      const head = new THREE.Mesh(headGeo, skinMat);
      head.position.y = 3.25;
      group.add(head);
      
      const hairGeo = new THREE.SphereGeometry(0.38, 20, 20, 0, Math.PI * 2, 0, Math.PI * 0.55);
      const hairMat = new THREE.MeshStandardMaterial({ color: 0x3a2a2a, roughness: 0.8 });
      const hair = new THREE.Mesh(hairGeo, hairMat);
      hair.position.y = 3.32;
      group.add(hair);
      
      // Veil
      const veilGeo = new THREE.ConeGeometry(0.55, 1.2, 18, 1, true);
      const veil = new THREE.Mesh(veilGeo, veilMat);
      veil.position.y = 3.1;
      veil.rotation.x = Math.PI;
      group.add(veil);
      
      // Crown/diadem
      const crownGeo = new THREE.TorusGeometry(0.22, 0.05, 12, 24);
      const crown = new THREE.Mesh(crownGeo, goldMat);
      crown.position.y = 3.45;
      crown.rotation.x = Math.PI / 2;
      group.add(crown);
      
      // Staff + glow
      const staffGroup = new THREE.Group();
      const staffGeo = new THREE.CylinderGeometry(0.04, 0.05, 3.2, 12);
      const staff = new THREE.Mesh(staffGeo, goldMat);
      staff.position.y = 1.5;
      staffGroup.add(staff);
      const orbGeo = new THREE.SphereGeometry(0.18, 16, 16);
      const orbMat = new THREE.MeshStandardMaterial({
        color: 0xa8e8ff,
        emissive: 0x66ccff,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.85
      });
      const orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.y = 3.2;
      staffGroup.add(orb);
      const orbLight = new THREE.PointLight(0x88ddff, 1.2, 10);
      orbLight.position.y = 3.2;
      staffGroup.add(orbLight);
      staffGroup.position.set(0.65, 0, 0.2);
      staffGroup.rotation.z = -0.1;
      group.add(staffGroup);
      
      // Glow aura
      const auraGeo = new THREE.SphereGeometry(1.2, 24, 24);
      const auraMat = new THREE.MeshBasicMaterial({
        color: 0x9bd3ff,
        transparent: true,
        opacity: 0.18,
        side: THREE.BackSide
      });
      const aura = new THREE.Mesh(auraGeo, auraMat);
      aura.position.y = 2.2;
      group.add(aura);
      
      return group;
    }
    
    function createRiverStyx() {
      clearScene();
      scene.background = new THREE.Color(0x050510);
      scene.fog = new THREE.FogExp2(0x050510, 0.04);
      
      const ambient = new THREE.AmbientLight(0x223344, 0.4);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // River
      const riverGeo = new THREE.PlaneGeometry(200, 50, 50, 20);
      const riverMat = new THREE.MeshStandardMaterial({ 
        color: 0x0a1a2a, 
        roughness: 0.1,
        transparent: true,
        opacity: 0.9
      });
      const river = new THREE.Mesh(riverGeo, riverMat);
      river.rotation.x = -Math.PI / 2;
      river.position.set(0, -1, 0);
      scene.add(river);
      sceneObjects.push(river);
      
      // Banks
      const bankGeo = new THREE.PlaneGeometry(200, 30);
      const bankMat = new THREE.MeshStandardMaterial({ color: 0x1a1a20, roughness: 0.95 });
      
      const nearBank = new THREE.Mesh(bankGeo, bankMat);
      nearBank.rotation.x = -Math.PI / 2;
      nearBank.position.set(0, 0, 40);
      scene.add(nearBank);
      sceneObjects.push(nearBank);
      
      // Charon and boat
      const charonBoat = createCharonBoat();
      charonBoat.position.set(0, -0.5, 10);
      scene.add(charonBoat);
      sceneObjects.push(charonBoat);
      charonBoat.userData.isCharon = true;
      interactables.push(charonBoat);
      
      // Priestess nearby
      const priestess = createPriestess();
      priestess.position.set(-3, 0, 25);
      scene.add(priestess);
      sceneObjects.push(priestess);
      
      // Dark landscape with dead trees
      const deadTreeMat = new THREE.MeshStandardMaterial({ color: 0x1a1510, roughness: 0.95 });
      
      // Create dead trees function
      function createDeadTree(x, z, scale) {
        const treeGroup = new THREE.Group();
        
        // Trunk - gnarled and twisted
        const trunkGeo = new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, 4 * scale, 8);
        const trunk = new THREE.Mesh(trunkGeo, deadTreeMat);
        trunk.position.y = 2 * scale;
        trunk.rotation.z = (Math.random() - 0.5) * 0.2;
        treeGroup.add(trunk);
        
        // Dead branches - twisted and bare
        const branchMat = new THREE.MeshStandardMaterial({ color: 0x0f0f0a, roughness: 0.9 });
        for (let i = 0; i < 5; i++) {
          const branchGeo = new THREE.CylinderGeometry(0.05 * scale, 0.15 * scale, 2.5 * scale, 6);
          const branch = new THREE.Mesh(branchGeo, branchMat);
          branch.position.set(
            (Math.random() - 0.5) * 0.5 * scale,
            (2.5 + i * 0.5) * scale,
            (Math.random() - 0.5) * 0.5 * scale
          );
          branch.rotation.x = (Math.random() - 0.3) * 1.2;
          branch.rotation.z = (Math.random() - 0.5) * 1.5;
          treeGroup.add(branch);
          
          // Sub-branches
          if (Math.random() > 0.4) {
            const subBranch = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02 * scale, 0.08 * scale, 1.5 * scale, 5),
              branchMat
            );
            subBranch.position.copy(branch.position);
            subBranch.position.y += 0.8 * scale;
            subBranch.rotation.x = branch.rotation.x + (Math.random() - 0.5);
            subBranch.rotation.z = branch.rotation.z + (Math.random() - 0.5) * 0.8;
            treeGroup.add(subBranch);
          }
        }
        
        treeGroup.position.set(x, 0, z);
        return treeGroup;
      }
      
      // Add dead trees around the scene
      const treePositions = [
        { x: -25, z: 35, s: 1.2 }, { x: -35, z: 45, s: 1.0 }, { x: -45, z: 30, s: 1.4 },
        { x: 25, z: 38, s: 1.1 }, { x: 38, z: 48, s: 0.9 }, { x: 50, z: 35, s: 1.3 },
        { x: -20, z: 55, s: 0.8 }, { x: 30, z: 58, s: 1.0 }, { x: -55, z: 50, s: 1.1 },
        { x: 55, z: 55, s: 0.9 }, { x: -15, z: -15, s: 1.0 }, { x: 20, z: -20, s: 1.2 },
        { x: -40, z: -10, s: 0.8 }, { x: 45, z: -15, s: 1.1 }
      ];
      
      treePositions.forEach(pos => {
        const tree = createDeadTree(pos.x, pos.z, pos.s);
        scene.add(tree);
        sceneObjects.push(tree);
      });
      
      // Dark ground plane extending into distance
      const groundGeo = new THREE.PlaneGeometry(300, 200);
      const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x0a0a08, 
        roughness: 1.0 
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.set(0, -0.1, 60);
      scene.add(ground);
      sceneObjects.push(ground);
      
      // Distant dark hills/mountains
      const hillMat = new THREE.MeshStandardMaterial({ color: 0x0d0d10, roughness: 0.95 });
      for (let i = 0; i < 8; i++) {
        const hillGeo = new THREE.ConeGeometry(15 + Math.random() * 20, 20 + Math.random() * 15, 6);
        const hill = new THREE.Mesh(hillGeo, hillMat);
        hill.position.set(
          (i - 4) * 35 + (Math.random() - 0.5) * 20,
          (10 + Math.random() * 8),
          80 + Math.random() * 30
        );
        hill.scale.x = 1.5 + Math.random() * 0.5;
        scene.add(hill);
        sceneObjects.push(hill);
      }
      
      // Eerie ambient glow points
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x20ffaa, transparent: true, opacity: 0.3 });
      for (let i = 0; i < 6; i++) {
        const glow = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), glowMat);
        glow.position.set(
          (Math.random() - 0.5) * 80,
          0.5 + Math.random() * 2,
          20 + Math.random() * 40
        );
        scene.add(glow);
        sceneObjects.push(glow);
      }
      
      playerPos.set(0, 1.7, 30);
      camera.position.copy(playerPos);
      yaw = Math.PI;
      canMove = true;
    }
    
    function createCharonBoat() {
      const group = new THREE.Group();
      
      // Boat
      const boatGeo = new THREE.BoxGeometry(3, 1, 8);
      const boatMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 });
      const boat = new THREE.Mesh(boatGeo, boatMat);
      boat.position.y = 0;
      group.add(boat);
      
      // Charon figure
      const charon = new THREE.Group();
      
      // Cloak
      const cloakGeo = new THREE.ConeGeometry(0.8, 3, 12);
      const cloakMat = new THREE.MeshStandardMaterial({ color: 0x111115, roughness: 0.95 });
      const cloak = new THREE.Mesh(cloakGeo, cloakMat);
      cloak.position.y = 2;
      charon.add(cloak);
      
      // Hood/skull
      const skullGeo = new THREE.SphereGeometry(0.35, 16, 16);
      const skullMat = new THREE.MeshStandardMaterial({ color: 0xd8d8c8, roughness: 0.6 });
      const skull = new THREE.Mesh(skullGeo, skullMat);
      skull.position.y = 3.5;
      charon.add(skull);
      
      // Glowing eyes
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
      const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.1, 3.55, 0.25);
      charon.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(0.1, 3.55, 0.25);
      charon.add(rightEye);
      
      // Staff
      const staffGeo = new THREE.CylinderGeometry(0.05, 0.06, 5, 10);
      const staff = new THREE.Mesh(staffGeo, new THREE.MeshStandardMaterial({ color: 0x3a2a1a }));
      staff.position.set(0.6, 2, 0);
      staff.rotation.z = -0.2;
      charon.add(staff);
      
      charon.position.set(0, 0.5, -2);
      group.add(charon);
      
      return group;
    }
    
    function createPuzzleRoom() {
      clearScene();
      scene.background = new THREE.Color(0x1a1a2a);
      
      const ambient = new THREE.AmbientLight(0x6666aa, 0.5);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // Floor
      const floorGeo = new THREE.PlaneGeometry(30, 30);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.8 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      sceneObjects.push(floor);
      
      // Walls
      const wallMat = new THREE.MeshStandardMaterial({ color: 0x3a3a4a, roughness: 0.7 });
      const wallGeo = new THREE.BoxGeometry(30, 8, 1);
      
      const backWall = new THREE.Mesh(wallGeo, wallMat);
      backWall.position.set(0, 4, -15);
      scene.add(backWall);
      sceneObjects.push(backWall);
      
      const frontWall = new THREE.Mesh(wallGeo, wallMat);
      frontWall.position.set(0, 4, 15);
      scene.add(frontWall);
      sceneObjects.push(frontWall);
      
      const sideWallGeo = new THREE.BoxGeometry(1, 8, 30);
      const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
      leftWall.position.set(-15, 4, 0);
      scene.add(leftWall);
      sceneObjects.push(leftWall);
      
      const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
      rightWall.position.set(15, 4, 0);
      scene.add(rightWall);
      sceneObjects.push(rightWall);
      
      // Orbs to collect
      orbsCollected = 0;
      puzzleOrbs = [];
      puzzleCoin = null;
      
      const orbPositions = [
        new THREE.Vector3(-10, 1.5, -10),
        new THREE.Vector3(10, 1.5, 0),
        new THREE.Vector3(0, 1.5, 10)
      ];
      
      orbPositions.forEach((pos, i) => {
        const orb = createPuzzleOrb();
        orb.position.copy(pos);
        orb.userData.isOrb = true;
        orb.userData.orbIndex = i;
        scene.add(orb);
        sceneObjects.push(orb);
        puzzleOrbs.push(orb);
        interactables.push(orb);
      });
      
      // Hide coin until all orbs collected
      document.getElementById('puzzle-ui').style.display = 'block';
      document.getElementById('orbs-collected').textContent = '0';
      
      playerPos.set(0, 1.7, 12);
      camera.position.copy(playerPos);
      yaw = Math.PI;
      canMove = true;
    }
    
    function createPuzzleOrb() {
      const group = new THREE.Group();
      
      const orbGeo = new THREE.SphereGeometry(0.5, 24, 24);
      const orbMat = new THREE.MeshStandardMaterial({ 
        color: 0x8844ff, 
        emissive: 0x4422aa,
        emissiveIntensity: 0.5,
        roughness: 0.1
      });
      const orb = new THREE.Mesh(orbGeo, orbMat);
      group.add(orb);
      
      const glowLight = new THREE.PointLight(0x8844ff, 0.5, 5);
      group.add(glowLight);
      
      return group;
    }
    
    function createCoin() {
      const group = new THREE.Group();
      
      const coinGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 24);
      const coin = new THREE.Mesh(coinGeo, materials.gold);
      coin.rotation.x = Math.PI / 2;
      group.add(coin);
      
      const glowLight = new THREE.PointLight(0xffd700, 0.5, 5);
      group.add(glowLight);
      
      return group;
    }
    
    function createHadesThrone() {
      clearScene();
      scene.background = new THREE.Color(0x050008);
      scene.fog = new THREE.FogExp2(0x050008, 0.02);
      
      const ambient = new THREE.AmbientLight(0x442266, 0.3);
      scene.add(ambient);
      sceneObjects.push(ambient);
      
      // Purple flames around
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const flame = new THREE.PointLight(0x8800ff, 2, 30);
        flame.position.set(Math.cos(angle) * 20, 5, Math.sin(angle) * 20);
        scene.add(flame);
        sceneObjects.push(flame);
      }
      
      // Center platform (island)
      const platformGeo = new THREE.CylinderGeometry(15, 18, 3, 32);
      const platformMat = new THREE.MeshStandardMaterial({ color: 0x1a0a2a, roughness: 0.8 });
      const platform = new THREE.Mesh(platformGeo, platformMat);
      platform.position.y = -1.5;
      platform.receiveShadow = true;
      scene.add(platform);
      sceneObjects.push(platform);
      
      // Abyss (dark water around)
      const abyssGeo = new THREE.PlaneGeometry(200, 200);
      const abyssMat = new THREE.MeshBasicMaterial({ color: 0x000005 });
      const abyss = new THREE.Mesh(abyssGeo, abyssMat);
      abyss.rotation.x = -Math.PI / 2;
      abyss.position.y = -5;
      scene.add(abyss);
      sceneObjects.push(abyss);
      
      // Hades throne
      const throne = createHadesThroneStructure();
      throne.position.set(0, 0, -8);
      scene.add(throne);
      sceneObjects.push(throne);
      
      // Hades himself - MUCH harder boss
      const hades = createHades();
      hades.position.set(0, 0, -5);
      hades.userData.isHades = true;
      hades.userData.health = 300; // Increased from 100 to 300
      scene.add(hades);
      sceneObjects.push(hades);
      enemies.push(hades);
      
      // Dead souls around the abyss edge
      for (let i = 0; i < 50; i++) {
        const ghost = createGhost();
        const angle = (i / 50) * Math.PI * 2;
        ghost.position.set(Math.cos(angle) * 25, -3, Math.sin(angle) * 25);
        scene.add(ghost);
        sceneObjects.push(ghost);
      }
      
      isInBattle = true;
      hadesHealth = 300; // Increased from 100 to 300
      document.getElementById('health-bar').style.display = 'flex';
      
      playerPos.set(0, 1.7, 10);
      camera.position.copy(playerPos);
      yaw = Math.PI;
      canMove = true;
    }
    
    function createHadesThroneStructure() {
      const group = new THREE.Group();
      
      // Base
      const baseGeo = new THREE.BoxGeometry(8, 4, 6);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x0a0015, roughness: 0.6 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 2;
      group.add(base);
      
      // Back
      const backGeo = new THREE.BoxGeometry(8, 15, 2);
      const back = new THREE.Mesh(backGeo, baseMat);
      back.position.set(0, 11.5, -2);
      group.add(back);
      
      // Skull decorations
      for (let i = 0; i < 3; i++) {
        const skullGeo = new THREE.SphereGeometry(0.5, 12, 12);
        const skullMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const skull = new THREE.Mesh(skullGeo, skullMat);
        skull.position.set(-2.5 + i * 2.5, 18, -1);
        skull.scale.set(1, 1.2, 0.9);
        group.add(skull);
      }
      
      return group;
    }
    
    function createHades() {
      const group = new THREE.Group();
      
      // Dark robe
      const robeGeo = new THREE.ConeGeometry(1.5, 4, 16);
      const robeMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a0828, 
        roughness: 0.4,
        emissive: 0x110020,
        emissiveIntensity: 0.3
      });
      const robe = new THREE.Mesh(robeGeo, robeMat);
      robe.position.y = 2;
      group.add(robe);
      
      // Upper body
      const torsoGeo = new THREE.CapsuleGeometry(0.8, 1.5, 12, 16);
      const torso = new THREE.Mesh(torsoGeo, robeMat);
      torso.position.y = 4.5;
      group.add(torso);
      
      // Skull head
      const skullGeo = new THREE.SphereGeometry(0.6, 20, 20);
      const skullMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.5 });
      const skull = new THREE.Mesh(skullGeo, skullMat);
      skull.position.y = 5.8;
      skull.scale.set(0.9, 1.1, 0.9);
      group.add(skull);
      
      // Glowing eyes
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
      const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.2, 5.9, 0.45);
      group.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
      rightEye.position.set(0.2, 5.9, 0.45);
      group.add(rightEye);
      
      // Crown
      const crownGeo = new THREE.TorusGeometry(0.5, 0.1, 12, 24);
      const crownMat = new THREE.MeshStandardMaterial({ 
        color: 0x440066, 
        metalness: 0.8,
        emissive: 0x220033,
        emissiveIntensity: 0.5
      });
      const crown = new THREE.Mesh(crownGeo, crownMat);
      crown.position.y = 6.4;
      crown.rotation.x = Math.PI / 2;
      group.add(crown);
      
      // Crown spikes
      for (let i = 0; i < 5; i++) {
        const spikeGeo = new THREE.ConeGeometry(0.08, 0.4, 8);
        const spike = new THREE.Mesh(spikeGeo, crownMat);
        const angle = (i / 5) * Math.PI * 2;
        spike.position.set(Math.cos(angle) * 0.5, 6.6, Math.sin(angle) * 0.5);
        group.add(spike);
      }
      
      // Bident
      const bidentGroup = new THREE.Group();
      const shaftGeo = new THREE.CylinderGeometry(0.06, 0.08, 5, 12);
      const shaftMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9 });
      const shaft = new THREE.Mesh(shaftGeo, shaftMat);
      shaft.position.y = 2.5;
      bidentGroup.add(shaft);
      
      const prongGeo = new THREE.ConeGeometry(0.08, 1, 8);
      const leftProng = new THREE.Mesh(prongGeo, shaftMat);
      leftProng.position.set(-0.15, 5.5, 0);
      bidentGroup.add(leftProng);
      
      const rightProng = new THREE.Mesh(prongGeo, shaftMat);
      rightProng.position.set(0.15, 5.5, 0);
      bidentGroup.add(rightProng);
      
      bidentGroup.position.set(1.2, 0, 0);
      bidentGroup.rotation.z = -0.15;
      group.add(bidentGroup);
      
      // Dark aura
      const auraMat = new THREE.MeshBasicMaterial({ 
        color: 0x8800ff, 
        transparent: true, 
        opacity: 0.2,
        side: THREE.BackSide
      });
      const auraGeo = new THREE.SphereGeometry(2.5, 24, 24);
      const aura = new THREE.Mesh(auraGeo, auraMat);
      aura.position.y = 3;
      group.add(aura);
      group.userData.aura = aura;
      
      return group;
    }
    
    function createLightningBolt() {
      const group = new THREE.Group();
      
      // Main bolt shape
      const boltShape = new THREE.Shape();
      boltShape.moveTo(0, 0);
      boltShape.lineTo(0.15, 0.4);
      boltShape.lineTo(0.05, 0.4);
      boltShape.lineTo(0.2, 0.9);
      boltShape.lineTo(0.08, 0.9);
      boltShape.lineTo(0.25, 1.5);
      boltShape.lineTo(0, 0.8);
      boltShape.lineTo(0.1, 0.8);
      boltShape.lineTo(-0.05, 0.35);
      boltShape.lineTo(0.05, 0.35);
      boltShape.lineTo(0, 0);
      
      const extrudeSettings = { depth: 0.1, bevelEnabled: false };
      const boltGeo = new THREE.ExtrudeGeometry(boltShape, extrudeSettings);
      const bolt = new THREE.Mesh(boltGeo, materials.lightning);
      bolt.scale.set(1.5, 1.5, 1.5);
      group.add(bolt);
      
      // Glow
      const glowLight = new THREE.PointLight(0xffff00, 2, 8);
      glowLight.position.y = 0.75;
      group.add(glowLight);
      
      // Electricity particles
      for (let i = 0; i < 5; i++) {
        const sparkGeo = new THREE.SphereGeometry(0.03, 6, 6);
        const sparkMat = new THREE.MeshBasicMaterial({ color: 0xaaffff });
        const spark = new THREE.Mesh(sparkGeo, sparkMat);
        spark.position.set(
          (Math.random() - 0.5) * 0.5,
          Math.random() * 1.5,
          (Math.random() - 0.5) * 0.3
        );
        spark.userData.originalPos = spark.position.clone();
        group.add(spark);
      }
      
      return group;
    }
    
    // ============ PLAYER HANDS (First Person) ============
    let playerHands = null;
    
    function createPlayerHands() {
      const group = new THREE.Group();
      group.userData.isPlayerHands = true;

      const skinMat = new THREE.MeshStandardMaterial({ color: 0xdbb896, roughness: 0.6 });
      const knuckleMat = new THREE.MeshStandardMaterial({ color: 0xd1aa86, roughness: 0.55 });

      // Simple edge hands (one left, one right) anchored to screen corners
      const leftHand = new THREE.Group();
      const rightHand = new THREE.Group();

      // Main palm sphere
      const palmGeo = new THREE.SphereGeometry(0.32, 20, 20);
      const leftPalm = new THREE.Mesh(palmGeo, skinMat);
      const rightPalm = new THREE.Mesh(palmGeo, skinMat);
      leftHand.add(leftPalm);
      rightHand.add(rightPalm);

      // Subtle knuckles for shape
      const knuckleGeo = new THREE.SphereGeometry(0.065, 12, 12);
      [-0.1, -0.035, 0.035, 0.1].forEach(x => {
        const k = new THREE.Mesh(knuckleGeo, knuckleMat);
        k.position.set(x, -0.08, -0.12);
        leftHand.add(k);
      });
      [-0.1, -0.035, 0.035, 0.1].forEach(x => {
        const k = new THREE.Mesh(knuckleGeo, knuckleMat);
        k.position.set(x, -0.08, -0.12);
        rightHand.add(k);
      });

      // Anchor to screen edges (corners), angled downward
      leftHand.position.set(-1.15, -0.75, -0.85);
      rightHand.position.set(1.15, -0.75, -0.85);
      leftHand.rotation.set(-0.7, 0.2, 0);
      rightHand.rotation.set(-0.7, -0.2, 0);

      group.add(leftHand);
      group.add(rightHand);

      // Store bases for swing animation
      group.userData.leftHand = leftHand;
      group.userData.rightHand = rightHand;
      group.userData.leftBase = new THREE.Vector3(-1.15, -0.75, -0.85);
      group.userData.rightBase = new THREE.Vector3(1.15, -0.75, -0.85);
      group.userData.leftBaseRot = new THREE.Euler(-0.7, 0.2, 0);
      group.userData.rightBaseRot = new THREE.Euler(-0.7, -0.2, 0);
      group.userData.swingPhase = 0;

      // Item holder follows right hand edge
      const itemHolder = new THREE.Group();
      itemHolder.position.set(0.0, -0.7, -0.85);
      group.add(itemHolder);
      group.userData.itemHolder = itemHolder;

      return group;
    }
    
    function updateHeldItem() {
      if (!playerHands) return;
      
      const holder = playerHands.userData.itemHolder;
      holder.clear();
      
      const item = inventory[selectedSlot];
      if (item === 'lightning') {
        const bolt = createLightningBolt();
        bolt.scale.set(0.5, 0.5, 0.5);
        bolt.rotation.z = -0.3;
        holder.add(bolt);
      } else if (item === 'coin') {
        const coin = createCoin();
        coin.scale.set(0.5, 0.5, 0.5);
        holder.add(coin);
      }
    }
    
    // ============ DIALOGUE SYSTEM ============
    function pushBossMessage(text, speaker = '') {
      const host = document.getElementById('boss-messages');
      if (!host) return;

      const msg = document.createElement('div');
      msg.className = 'boss-msg';

      if (speaker && speaker.trim()) {
        const sp = document.createElement('span');
        sp.className = 'boss-speaker';
        sp.textContent = speaker;
        msg.appendChild(sp);
      }

      const body = document.createElement('div');
      body.textContent = text;
      msg.appendChild(body);

      host.appendChild(msg);

      // Overlap/stack, auto-expire (no dismiss controls; never blocks input)
      const ttl = 5000;
      setTimeout(() => {
        if (msg.parentNode === host) host.removeChild(msg);
      }, ttl);

      // Keep a sane cap
      while (host.children.length > 6) {
        host.removeChild(host.firstElementChild);
      }
    }

    function showNarration(text, speaker = 'Your Consciousness') {
      // Boss battle: show non-blocking stacked messages above the boss health bar.
      if (isInBattle && currentScene === 'hades') {
        pushBossMessage(text, speaker === 'Your Consciousness' ? '' : speaker);
        return;
      }
      dialogueQueue.push({ text, speaker });
      if (!isDialogueOpen) {
        displayNextDialogue();
      }
    }
    
    function displayNextDialogue() {
      if (dialogueQueue.length === 0) {
        isDialogueOpen = false;
        document.getElementById('narrator-box').style.display = 'none';
        return;
      }
      
      isDialogueOpen = true;
      const { text, speaker } = dialogueQueue.shift();
      document.getElementById('narrator-box').style.display = 'block';
      document.getElementById('narrator-box').querySelector('.speaker').textContent = speaker;
      document.getElementById('narrator-box').querySelector('.text').textContent = text;
    }
    
    function advanceDialogue() {
      if (dialogueQueue.length > 0) {
        displayNextDialogue();
      } else {
        isDialogueOpen = false;
        document.getElementById('narrator-box').style.display = 'none';
        onDialogueEnd();
      }
    }
    
    let pendingSceneAction = null;
    
    function onDialogueEnd() {
      if (pendingSceneAction) {
        pendingSceneAction();
        pendingSceneAction = null;
      }
    }
    
    // ============ SCENE TRANSITIONS ============
    function fadeToBlack(callback) {
      const overlay = document.getElementById('fade-overlay');
      overlay.classList.remove('white');
      overlay.classList.add('active');
      setTimeout(() => {
        callback();
        setTimeout(() => {
          overlay.classList.remove('active');
        }, 500);
      }, 500);
    }
    
    function fadeToWhite(callback) {
      const overlay = document.getElementById('fade-overlay');
      overlay.classList.add('white');
      overlay.classList.add('active');
      setTimeout(() => {
        callback();
        setTimeout(() => {
          overlay.classList.remove('active');
          overlay.classList.remove('white');
        }, 500);
      }, 500);
    }
    
    // ============ GAME SEQUENCE ============
    function startGame() {
      initAudio();
      preloadDeathSound(); // Preload death/bruh sound
      gameState = 'playing';
      currentScene = 'mortal';
      
      createMortalRealm();
      
      // IMPORTANT: Set spawn direction AFTER createMortalRealm()
      // Player spawns at z=10 facing the staircase at z=-30
      // In three.js the camera faces -Z by default, so yaw = 0 faces the staircase
      // Portal is behind at z=20, so player faces away from it
      playerPos.set(0, 1.7, 10);
      camera.position.copy(playerPos);
      yaw = 0;  // Face toward negative Z (staircase)
      pitch = 0;
      
      // Apply camera rotation immediately so player sees correct direction on first frame
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      
      // Create player hands
      camera.children.slice().forEach(child => {
        if (child.userData?.isPlayerHands) {
          camera.remove(child);
        }
      });
      if (playerHands) {
        camera.remove(playerHands);
      }
      playerHands = createPlayerHands();
      playerHands.scale.set(1, 1, 1);
      playerHands.position.set(0, 0, 0);
      camera.add(playerHands);
      scene.add(camera);
      
      document.getElementById('crosshair').style.display = 'block';
      
      // ENHANCEMENT: Show pause button
      document.getElementById('pause-button').style.display = 'flex';
      
      // ENHANCEMENT: Start nature ambient sounds
      playBackgroundSound('nature');
      
      // Initial narration
      setTimeout(() => {
        showNarration("Where... where am I?");
        showNarration("I find myself in a beautiful meadow, surrounded by flowers and trees.");
        showNarration("But wait... there's a strange staircase ahead. It seems to float in the air, leading up into the clouds.");
        showNarration("Something tells me I must climb it.");
        pendingSceneAction = () => { canMove = true; };
      }, 1000);
    }

    // Note: Pause menu handlers moved to top with audio system
    
    function enterStaircase() {
      fadeToWhite(() => {
        currentScene = 'staircase';
        canOnlyMoveForward = true;
        
        clearScene();
        scene.background = new THREE.Color(0xaabbcc);
        scene.fog = new THREE.Fog(0xaabbcc, 20, 120);
        
        // Staircase environment
        const ambient = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambient);
        sceneObjects.push(ambient);
        canOnlyMoveForward = false; // allow full movement on cloudy path
        
        const sunLight = new THREE.DirectionalLight(0xffffee, 1);
        sunLight.position.set(20, 50, 20);
        scene.add(sunLight);
        sceneObjects.push(sunLight);
        
        // Create floating steps - 150 steps to reach the fortress
        const stairRise = 0.15;
        const stairRun = 1.8;
        for (let i = 0; i < 150; i++) {
          const stepGeo = new THREE.BoxGeometry(4.5, 0.25, 2.2);
          const step = new THREE.Mesh(stepGeo, materials.marble);
          step.position.set(0, i * stairRise, -i * stairRun);
          step.castShadow = true;
          step.receiveShadow = true;
          scene.add(step);
          sceneObjects.push(step);
          
          // Glow
          const glowGeo = new THREE.PlaneGeometry(4, 2);
          const glowMat = new THREE.MeshBasicMaterial({ 
            color: 0xaaddff, 
            transparent: true, 
            opacity: 0.25,
            side: THREE.DoubleSide 
          });
          const glow = new THREE.Mesh(glowGeo, glowMat);
          glow.position.set(0, i * stairRise - 0.13, -i * stairRun);
          glow.rotation.x = -Math.PI / 2;
          scene.add(glow);
          sceneObjects.push(glow);
        }
        
        // Visible side railings
        const railMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.3, metalness: 0.5 });
        for (let i = 0; i < 150; i += 4) {
          const postGeo = new THREE.CylinderGeometry(0.06, 0.06, 1.2, 8);
          const leftPost = new THREE.Mesh(postGeo, railMat);
          leftPost.position.set(-2, i * stairRise + 0.6, -i * stairRun);
          scene.add(leftPost);
          sceneObjects.push(leftPost);
          
          const rightPost = new THREE.Mesh(postGeo, railMat);
          rightPost.position.set(2, i * stairRise + 0.6, -i * stairRun);
          scene.add(rightPost);
          sceneObjects.push(rightPost);
        }
        
        // Clouds around - sparse for clearer view
        for (let i = 0; i < 35; i++) {
          const cloudGroup = new THREE.Group();
          for (let j = 0; j < 3; j++) {
            const puffGeo = new THREE.SphereGeometry(4 + Math.random() * 6, 10, 10);
            const puff = new THREE.Mesh(puffGeo, materials.cloud);
            puff.position.set((Math.random() - 0.5) * 12, Math.random() * 4, (Math.random() - 0.5) * 8);
            cloudGroup.add(puff);
          }
          cloudGroup.position.set(
            (Math.random() - 0.5) * 100,
            Math.random() * 40 - 10,
            -Math.random() * 300
          );
          scene.add(cloudGroup);
          sceneObjects.push(cloudGroup);
        }
        
        // Fortress silhouette in the distance (visible from start)
        const fortressHint = new THREE.Group();
        const towerGeo = new THREE.BoxGeometry(15, 50, 15);
        const towerMat = new THREE.MeshStandardMaterial({ color: 0x3a3a45, roughness: 0.85 });
        const tower1 = new THREE.Mesh(towerGeo, towerMat);
        tower1.position.set(-22, 45, -280);
        fortressHint.add(tower1);
        const tower2 = new THREE.Mesh(towerGeo, towerMat);
        tower2.position.set(22, 45, -280);
        fortressHint.add(tower2);
        
        // Gate archway frame
        const archMat = new THREE.MeshStandardMaterial({ color: 0x2a2a35, roughness: 0.9, metalness: 0.2 });
        const leftPillar = new THREE.Mesh(new THREE.BoxGeometry(5, 40, 8), archMat);
        leftPillar.position.set(-12, 20, -278);
        fortressHint.add(leftPillar);
        const rightPillar = new THREE.Mesh(new THREE.BoxGeometry(5, 40, 8), archMat);
        rightPillar.position.set(12, 20, -278);
        fortressHint.add(rightPillar);
        const archTop = new THREE.Mesh(new THREE.BoxGeometry(29, 6, 8), archMat);
        archTop.position.set(0, 42, -278);
        fortressHint.add(archTop);
        
        // Gate bars (iron gate look)
        const barMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.8 });
        for (let i = -4; i <= 4; i++) {
          const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 36, 8), barMat);
          bar.position.set(i * 2.2, 18, -276);
          fortressHint.add(bar);
        }
        // Horizontal bars
        const hBar1 = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 20, 8), barMat);
        hBar1.rotation.z = Math.PI / 2;
        hBar1.position.set(0, 12, -276);
        fortressHint.add(hBar1);
        const hBar2 = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 20, 8), barMat);
        hBar2.rotation.z = Math.PI / 2;
        hBar2.position.set(0, 26, -276);
        fortressHint.add(hBar2);
        
        // Decorative spikes on top of gate
        for (let i = -4; i <= 4; i++) {
          const spike = new THREE.Mesh(new THREE.ConeGeometry(0.4, 2, 6), barMat);
          spike.position.set(i * 2.2, 38, -276);
          fortressHint.add(spike);
        }
        
        scene.add(fortressHint);
        sceneObjects.push(fortressHint);
        
        playerPos.set(0, 2, 0);
        camera.position.copy(playerPos);
        yaw = Math.PI;
        canMove = true;
        
        // Play heavenly music for staircase
        playBackgroundSound('staircase');
        
        showNarration("The staircase stretches endlessly upward...");
        showNarration("As I climb, the world below begins to fade away into mist.");
        showNarration("I can see a fortress in the distance, shrouded in clouds.");
      });
    }
    
    function enterFortress() {
      fadeToWhite(() => {
        currentScene = 'fortress';
        createFortressGates();
        canMove = true;
        
        // Continue heavenly music in fortress/castle
        playBackgroundSound('olympus');
        
        showNarration("A massive fortress emerges from the clouds before me.");
        showNarration("Two imposing guardians stand at the gate, their staffs crossed over the entrance.");
        showNarration("They stand perfectly still, like statues carved from living stone.");
        
        pendingSceneAction = () => {
          canMove = true;
        };
      });
    }
    
    // Check if player is close enough to trigger fortress sequence
    function checkFortressTrigger() {
      if (currentScene !== 'fortress' || doorsOpening || doorsOpen) return;
      
      // Trigger when player gets close to guardians
      if (playerPos.z < -15) {
        doorsOpening = true;
        canMove = false;
        
        showNarration("The guardians turn their heads to look at me...");
        
        // Animate guardians looking at player
        setTimeout(() => {
          if (fortressGuardians.left) {
            fortressGuardians.left.rotation.y = 0.5;
          }
          if (fortressGuardians.right) {
            fortressGuardians.right.rotation.y = -0.5;
          }
        }, 500);
        
        setTimeout(() => {
          showNarration("They study me for a moment... then slowly raise their staffs.");
          
          // Animate staffs moving aside
          let staffAngle = -0.5;
          const staffInterval = setInterval(() => {
            staffAngle += 0.02;
            if (fortressGuardians.left && fortressGuardians.left.userData.staff) {
              fortressGuardians.left.userData.staff.rotation.z = -staffAngle - 0.3;
            }
            if (fortressGuardians.right && fortressGuardians.right.userData.staff) {
              fortressGuardians.right.userData.staff.rotation.z = staffAngle + 0.3;
            }
            
            if (staffAngle >= 0.8) {
              clearInterval(staffInterval);
              
              // Now open the doors
              setTimeout(() => {
                showNarration("The great doors begin to creak open...");
                playSound('door');
                
                // Animate doors opening
                let doorAngle = 0;
                const doorInterval = setInterval(() => {
                  doorAngle += 0.008;
                  
                  if (fortressDoors.left) {
                    fortressDoors.left.rotation.y = doorAngle;
                  }
                  if (fortressDoors.right) {
                    fortressDoors.right.rotation.y = -doorAngle;
                  }
                  
                  if (doorAngle >= Math.PI / 2.2) {
                    clearInterval(doorInterval);
                    doorsOpen = true;
                    
                    // Blinding light from inside
                    const gateLight = new THREE.PointLight(0xffffff, 5, 50);
                    gateLight.position.set(0, 10, -32);
                    scene.add(gateLight);
                    sceneObjects.push(gateLight);
                    
                    setTimeout(() => {
                      showNarration("A blinding white light pours from within...");
                      showNarration("The guardians step aside, allowing me passage.");
                      
                      // Move guardians to the side
                      if (fortressGuardians.left) {
                        fortressGuardians.left.position.x = -12;
                        fortressGuardians.left.rotation.y = Math.PI / 2;
                      }
                      if (fortressGuardians.right) {
                        fortressGuardians.right.position.x = 12;
                        fortressGuardians.right.rotation.y = -Math.PI / 2;
                      }
                      
                      canMove = true;
                      
                      pendingSceneAction = () => {
                        // Player can now walk through
                      };
                    }, 1000);
                  }
                }, 16);
              }, 1000);
            }
          }, 16);
        }, 2000);
      }
    }
    
    // Check if player walks through the open doors
    function checkFortressEntry() {
      if (currentScene !== 'fortress' || !doorsOpen) return;
      
      // Player walked through the doors
      if (playerPos.z < -35) {
        doorsOpen = false; // Prevent re-triggering
        canMove = false;
        
        showNarration("I step through the doorway into the blinding light...");
        
        setTimeout(() => {
          enterOlympus();
        }, 1500);
      }
    }
    
    function enterOlympus() {
      fadeToWhite(() => {
        currentScene = 'olympus';
        createOlympusThrone();
        playBackgroundSound('olympus'); // ENHANCEMENT: Background music
        canOnlyMoveForward = false; // allow full movement in Zeus room
        
        setTimeout(() => {
          showNarration("The blinding light slowly fades...");
          showNarration("I find myself in a chamber of impossible scale. Marble pillars stretch into the fog above.");
          showNarration("A bed of clouds lies beneath my feet, and a red carpet leads forward.");
          showNarration("I can only walk straight ahead...");
          
          pendingSceneAction = () => {
            canMove = true;
            setTimeout(() => {
              showNarration("Hello? Anybody there?", "Your Consciousness");
            }, 2000);
          };
        }, 5000); // 5 seconds of white
      });
    }
    
    function meetZeus() {
      if (zeusMet) return;
      zeusMet = true;
      canMove = false;
      
      showNarration("Before me sits a throne of unimaginable size.", "");
      showNarration("Upon it rests a figure so massive, his head disappears into the clouds above.", "");
      
      setTimeout(() => {
        playSound('thunder');
        showNarration("MORTAL. I AM ZEUS, KING OF THE GODS.", "Zeus");
        showNarration("Hades, my brother, has betrayed us all. He seeks to unleash the dead upon the living world.", "Zeus");
        showNarration("You have been chosen to stop him. Take this - my lightning bolt. It holds the power of the storms themselves.", "Zeus");
        
        // Add lightning bolt to inventory
        inventory[0] = 'lightning';
        updateInventoryUI();
        updateHeldItem();
        document.getElementById('inventory').style.display = 'flex';
        
        showNarration("Use it well. Throw it at your enemies, or wield it in close combat.", "Zeus");
        showNarration("A priestess awaits you in the underworld. She will guide your path.", "Zeus");
        showNarration("Now go... and may the gods be with you.", "Zeus");
        
        pendingSceneAction = () => {
          showNarration("Suddenly, the floor gives way beneath me!");
          setTimeout(() => startFalling(), 1500);
        };
      }, 500);
    }
    
    function startFalling() {
      fadeToBlack(() => {
        currentScene = 'falling';
        canMove = false;
        
        clearScene();
        scene.background = new THREE.Color(0x000000);
        
        // Simulate falling with shaking camera
        let fallTime = 0;
        const fallDuration = 5000;
        
        const fallInterval = setInterval(() => {
          fallTime += 16;
          
          // Camera shake
          camera.rotation.x = (Math.random() - 0.5) * 0.3;
          camera.rotation.z = (Math.random() - 0.5) * 0.2;
          
          // Show hands flailing
          if (playerHands) {
            playerHands.position.x = (Math.random() - 0.5) * 0.3;
            playerHands.position.y = (Math.random() - 0.5) * 0.3;
          }
          
          if (fallTime >= fallDuration) {
            clearInterval(fallInterval);
            camera.rotation.x = 0;
            camera.rotation.z = 0;
            if (playerHands) {
              playerHands.position.set(0, 0, 0);
            }
            landInUnderworld();
          }
        }, 16);
        
        showNarration("I'm falling... falling into darkness!");
        showNarration("The tunnel grows darker and darker...");
      });
    }
    
    function landInUnderworld() {
      fadeToBlack(() => {
        currentScene = 'underworld';
        createUnderworld();
        playBackgroundSound('underworld'); // ENHANCEMENT: Background music
        
        // Start looking at ground
        pitch = -0.8;
        canMove = false;
        canLook = false;
        
        // Blur effect simulation
        setTimeout(() => {
          showNarration("Ugh... my head...");
          showNarration("I look at my trembling hands... Where am I?");
          
          // Slowly look up
          const lookUpInterval = setInterval(() => {
            pitch += 0.02;
            if (pitch >= 0) {
              pitch = 0;
              clearInterval(lookUpInterval);
              canLook = true;
              
              showNarration("What... what is this place?!");
              showNarration("*GASP* Thousands of souls... wandering aimlessly...");
              showNarration("Their ghostly forms pass through each other, oblivious to everything.");
              showNarration("Is that... Medusa? And Hercules on that distant mountain?");
              
              // Priestess appears
              showNarration("Calm yourself, hero. I am the Priestess who will guide you.", "Priestess");
              showNarration("Stand up. You have a long journey ahead.", "Priestess");
              
              pendingSceneAction = () => {
                canMove = true;
                showNarration("Follow me to the River Styx. Charon awaits.", "Priestess");
                
                setTimeout(() => goToStyx(), 5000);
              };
            }
          }, 50);
        }, 1500);
      });
    }
    
    function goToStyx() {
      fadeToBlack(() => {
        currentScene = 'styx';
        createRiverStyx();
        playBackgroundSound('styx'); // ENHANCEMENT: Background music
        
        showNarration("The dark waters of the Styx stretch before us...");
        showNarration("Charon, the ferryman, waits silently in his boat.");
        
        setTimeout(() => {
          showNarration("Oh no! I didn't bring payment for the crossing!");
          
          // Show body switch menu
          document.getElementById('body-switch-menu').style.display = 'flex';
          canMove = false;
        }, 2000);
      });
    }
    
function switchToPerseus() {
  document.getElementById('body-switch-menu').style.display = 'none';
  
  fadeToBlack(() => {
  currentScene = 'puzzle';
  
  // Launch the escape room puzzle instead of simple orb collection
  showNarration("I find myself in Perseus's body... in some kind of ancient puzzle chamber.");
  showNarration("I must solve the three rooms to obtain the coin for Charon!");
  
  setTimeout(() => {
    startEscapeRoom();
  }, 3000);
  });
  }
    
    function collectOrb(orbIndex) {
      const orb = puzzleOrbs.find(o => o.userData.orbIndex === orbIndex);
      if (orb) {
        scene.remove(orb);
        puzzleOrbs = puzzleOrbs.filter(o => o !== orb);
        orbsCollected++;
        document.getElementById('orbs-collected').textContent = orbsCollected;
        playSound('collect');
        
        if (orbsCollected >= 3) {
          showNarration("All orbs collected! A coin appears!");
          spawnPuzzleCoin();
        }
      }
    }
    
    function spawnPuzzleCoin() {
      if (puzzleCoin) return;
      puzzleCoin = createCoin();
      puzzleCoin.position.set(0, 1, -12);
      puzzleCoin.userData.isCoin = true;
      scene.add(puzzleCoin);
      sceneObjects.push(puzzleCoin);
      interactables.push(puzzleCoin);
    }
    
    function collectCoin() {
      if (orbsCollected < 3) {
        showNarration("I need to collect all the orbs first...");
        return;
      }
      
      if (puzzleCoin) {
        scene.remove(puzzleCoin);
        puzzleCoin = null;
      }
      
      inventory[1] = 'coin';
      updateInventoryUI();
      playSound('collect');
      document.getElementById('puzzle-ui').style.display = 'none';
      
      showNarration("I have the coin! Time to return to my body.");
      
      setTimeout(() => returnToAeneas(), 2000);
    }
    
    function returnToAeneas() {
      fadeToBlack(() => {
        currentScene = 'styx';
        createRiverStyx();
        
        document.getElementById('body-switch-menu').style.display = 'none';
        
        showNarration("I'm back in my own body... and I have the coin!");
        showNarration("Now I can pay Charon for passage.");
        
        canMove = true;
      });
    }
    
    function payCharon() {
      if (inventory[1] !== 'coin') {
        showNarration("I need a coin to pay the ferryman...");
        return;
      }
      
      inventory[1] = null;
      updateInventoryUI();
      
      showNarration("I hand the coin to Charon. He nods silently.", "");
      
      fadeToBlack(() => {
        currentScene = 'boat';
        
        clearScene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.03);
        
        // Boat environment
        const ambient = new THREE.AmbientLight(0x223344, 0.3);
        scene.add(ambient);
        sceneObjects.push(ambient);
        
        // Water
        const waterGeo = new THREE.PlaneGeometry(200, 200);
        const water = new THREE.Mesh(waterGeo, materials.water);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -1;
        scene.add(water);
        sceneObjects.push(water);
        
        // Simple boat around player
        const boatGeo = new THREE.BoxGeometry(3, 1, 6);
        const boat = new THREE.Mesh(boatGeo, materials.wood);
        boat.position.y = -0.5;
        scene.add(boat);
        sceneObjects.push(boat);
        
        playerPos.set(0, 1, 2);
        camera.position.copy(playerPos);
        canMove = false;
        
        showNarration("The boat sways gently as Charon rows through the dark waters...");
        showNarration("I sit in the back, contemplating the journey ahead.");
        
        // Boat ride animation
        let boatTime = 0;
        const boatInterval = setInterval(() => {
          boatTime += 16;
          camera.position.y = 1 + Math.sin(boatTime * 0.002) * 0.1;
          camera.position.x = Math.sin(boatTime * 0.001) * 0.05;
          
          if (boatTime > 8000) {
            clearInterval(boatInterval);
            passCerberus();
          }
        }, 16);
      });
    }
    
    // ENHANCEMENT: Complete Cerberus Minigame
    let cerberusMinigame = {
      active: false,
      boatHealth: 100,
      score: 0,
      time: 0,
      heads: [],
      warnings: [],
      difficulty: 1
    };
    let boatX = 50;
    let cerberusTouchX = null;

    function startCerberusMinigame() {
      cerberusMinigame = {
        active: true,
        boatHealth: 100,
        score: 0,
        time: 0,
        heads: [],
        warnings: [],
        difficulty: 1
      };
      boatX = 50;
      
      const container = document.getElementById('cerberus-minigame');
      container.style.display = 'block';
      container.innerHTML = `
        <div style="position:absolute;top:0;width:100%;height:50%;background:linear-gradient(180deg,#1a0a2a 0%,#2a1a3a 50%,#3a2a4a 100%);"></div>
        <div style="position:absolute;bottom:0;width:100%;height:50%;background:linear-gradient(180deg,#0a2a3a 0%,#0a1a2a 50%,#050510 100%);overflow:hidden;">
          <div style="position:absolute;bottom:0;width:150%;height:30px;background:repeating-linear-gradient(90deg,#1a3a4a 0px,#0a2a3a 100px,#1a3a4a 200px);border-radius:50%;animation:waveAnim 3s ease-in-out infinite;"></div>
        </div>
        
        <div id="cerberus-boat" style="position:absolute;bottom:10%;left:50%;transform:translateX(-50%);width:200px;height:80px;z-index:10;transition:left 0.1s ease-out;">
          <div style="width:100%;height:100%;background:linear-gradient(145deg,#6b4423,#4a2a1a);border-radius:50% 50% 20% 20%;border:3px solid #3a1a0a;position:relative;box-shadow:0 10px 20px rgba(0,0,0,0.5);">
            <div id="boat-damage" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"></div>
          </div>
        </div>
        
        <div style="position:absolute;top:20px;left:20px;z-index:20;color:white;font-family:'Cinzel',serif;">
          <div style="background:rgba(0,0,0,0.7);padding:15px;border-radius:10px;border:2px solid #8800ff;">
            <div>Boat Health: <span id="cerberus-health">100</span>%</div>
            <div>Time: <span id="cerberus-time">0</span>s</div>
            <div>Dodged: <span id="cerberus-score">0</span></div>
          </div>
        </div>
        
        <div id="cerberus-instructions" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);padding:30px;border-radius:15px;border:3px solid #ff0000;color:white;text-align:center;font-family:'Cinzel',serif;z-index:30;">
          <h2 style="color:#ff4444;margin-bottom:15px;font-size:2rem;">CERBERUS GAUNTLET</h2>
          <p style="margin:10px 0;">Dodge the falling heads of Cerberus!</p>
          <p style="margin:10px 0;">‚ö†Ô∏è Red zones show where heads will strike</p>
          <p style="margin:10px 0;">Move left/right to avoid damage</p>
          <button id="start-cerberus" style="margin-top:20px;padding:15px 40px;background:linear-gradient(145deg,#c9a227,#8b6914);border:none;border-radius:10px;font-size:1.2rem;cursor:pointer;font-family:'Cinzel',serif;color:#000;">START</button>
        </div>
      `;
      
      document.getElementById('start-cerberus').addEventListener('click', () => {
        document.getElementById('cerberus-instructions').remove();
        cerberusGameLoop();
      });
    }

    function cerberusGameLoop() {
      if (!cerberusMinigame.active) return;
      
      cerberusMinigame.time += 1/60;
      document.getElementById('cerberus-time').textContent = Math.floor(cerberusMinigame.time);
      
      if (Math.random() < 0.015 * cerberusMinigame.difficulty) {
        spawnCerberusHead();
      }
      
      const boatContainer = document.getElementById('cerberus-boat');
      if (!boatContainer) return;
      const boatRect = boatContainer.getBoundingClientRect();
      
      cerberusMinigame.warnings = cerberusMinigame.warnings.filter(warning => {
        warning.time += 1/60;
        if (warning.time > 2 && !warning.spawned) {
          warning.spawned = true;
          const head = document.createElement('div');
          head.style.cssText = 'position:absolute;left:' + warning.x + '%;top:-50px;width:60px;height:60px;font-size:40px;z-index:15;';
          head.textContent = 'üêï';
          document.getElementById('cerberus-minigame').appendChild(head);
          cerberusMinigame.heads.push({ element: head, x: warning.x, y: -50 });
        }
        return warning.time < 2;
      });
      
      cerberusMinigame.heads = cerberusMinigame.heads.filter(head => {
        head.y += 3 * cerberusMinigame.difficulty;
        head.element.style.top = head.y + 'px';
        
        const headRect = head.element.getBoundingClientRect();
        
        if (headRect.bottom >= boatRect.top && headRect.top <= boatRect.bottom &&
            headRect.right >= boatRect.left && headRect.left <= boatRect.right) {
          cerberusMinigame.boatHealth -= 15;
          document.getElementById('cerberus-health').textContent = Math.max(0, cerberusMinigame.boatHealth);
          addBoatDamage();
          playSound('hit');
          head.element.remove();
          
          if (cerberusMinigame.boatHealth <= 0) {
            endCerberusMinigame(false);
          }
          return false;
        }
        
        if (head.y > window.innerHeight) {
          cerberusMinigame.score++;
          document.getElementById('cerberus-score').textContent = cerberusMinigame.score;
          head.element.remove();
          return false;
        }
        
        return true;
      });
      
      cerberusMinigame.difficulty = 1 + (cerberusMinigame.time / 30);
      
      if (cerberusMinigame.time > 30) {
        endCerberusMinigame(true);
        return;
      }
      
      requestAnimationFrame(cerberusGameLoop);
    }

    function spawnCerberusHead() {
      const x = 20 + Math.random() * 60;
      const warning = document.createElement('div');
      warning.style.cssText = 'position:absolute;left:' + x + '%;top:0;width:80px;height:100%;background:rgba(255,0,0,0.3);border:3px solid #ff0000;border-top:none;z-index:5;animation:warningPulse 0.5s infinite;';
      warning.innerHTML = '<div style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);padding:5px 10px;border-radius:5px;font-weight:bold;color:white;">‚ö†Ô∏è</div>';
      document.getElementById('cerberus-minigame').appendChild(warning);
      
      cerberusMinigame.warnings.push({ element: warning, x: x, time: 0, spawned: false });
      setTimeout(() => warning.remove(), 2000);
    }

    function addBoatDamage() {
      const container = document.getElementById('boat-damage');
      if (!container) return;
      const crack = document.createElement('div');
      crack.style.cssText = 'position:absolute;left:' + (Math.random()*80+10) + '%;top:' + (Math.random()*80+10) + '%;width:2px;height:' + (20+Math.random()*30) + 'px;background:linear-gradient(180deg,transparent,#000,transparent);transform:rotate(' + (Math.random()*360) + 'deg);';
      container.appendChild(crack);
    }

    function endCerberusMinigame(won) {
      cerberusMinigame.active = false;
      const container = document.getElementById('cerberus-minigame');
      container.innerHTML = '<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:40px;border-radius:20px;border:3px solid ' + (won?'#00ff00':'#ff0000') + ';color:white;text-align:center;font-family:\'Cinzel\',serif;z-index:100;"><h1 style="color:' + (won?'#00ff00':'#ff0000') + ';font-size:3rem;margin-bottom:20px;">' + (won?'‚úÖ SURVIVED!':'üíÄ WRECKED!') + '</h1><p style="font-size:1.5rem;">Heads Dodged: ' + cerberusMinigame.score + '</p><p style="font-size:1.2rem;margin-top:10px;">Time: ' + Math.floor(cerberusMinigame.time) + 's</p></div>';
      
      setTimeout(() => {
        container.style.display = 'none';
        if (won) {
          // Continue game
          fadeToBlack(() => {
            showNarration("You survived Cerberus! Charon nods approvingly...");
            showNarration("Finally, we reach the shore. Charon departs silently.");
            showNarration("Before me... the throne of Hades himself.");
            showNarration("Countless souls surround the River Lethe, seeking rebirth.");
            showNarration("But in the center... an island. And upon it, HADES.", "");
            
            pendingSceneAction = () => {
              enterHadesBattle();
            };
          });
        } else {
          if (confirm('Try again?')) {
            startCerberusMinigame();
          } else {
            // Skip minigame on failure
            fadeToBlack(() => {
              showNarration("Despite the damage, we made it through...");
              showNarration("Finally, we reach the shore. Charon departs silently.");
              showNarration("Before me... the throne of Hades himself.");
              pendingSceneAction = () => {
                enterHadesBattle();
              };
            });
          }
        }
      }, 3000);
    }

    // Boat controls for Cerberus minigame
    document.addEventListener('keydown', (e) => {
      if (!cerberusMinigame.active) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        boatX = Math.max(10, boatX - 2);
        const boat = document.getElementById('cerberus-boat');
        if (boat) boat.style.left = boatX + '%';
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        boatX = Math.min(90, boatX + 2);
        const boat = document.getElementById('cerberus-boat');
        if (boat) boat.style.left = boatX + '%';
      }
    });

    document.addEventListener('touchstart', (e) => {
      if (!cerberusMinigame.active) return;
      cerberusTouchX = e.touches[0].clientX;
    });

    document.addEventListener('touchmove', (e) => {
      if (!cerberusMinigame.active || cerberusTouchX === null) return;
      const deltaX = e.touches[0].clientX - cerberusTouchX;
      boatX = Math.max(10, Math.min(90, boatX + deltaX / window.innerWidth * 100));
      const boat = document.getElementById('cerberus-boat');
      if (boat) boat.style.left = boatX + '%';
      cerberusTouchX = e.touches[0].clientX;
    });

    document.addEventListener('touchend', () => {
      cerberusTouchX = null;
    });

    // OLD passCerberus function - now calls minigame
    function passCerberus() {
      startCerberusMinigame();
    }
    
    function enterHadesBattle() {
      fadeToBlack(() => {
        currentScene = 'hades';

        // Boss battle should never be blocked by the narration dialogue box
        dialogueQueue = [];
        isDialogueOpen = false;
        const narratorBox = document.getElementById('narrator-box');
        if (narratorBox) narratorBox.style.display = 'none';
        
        // Reset skeleton warriors array before creating new battle
        skeletonWarriors = [];
        lastSkeletonSpawnTime = Date.now();
        
        createHadesThrone();
        
        // Play intense battle music
        playBackgroundSound('battle');
        
        // Ensure player has lightning bolt for the battle (especially for mobile accessibility)
        inventory[0] = 'lightning';
        updateInventoryUI();
        updateHeldItem();
        document.getElementById('inventory').style.display = 'flex';
        
        // Show battle UI
        document.getElementById('player-lives').style.display = 'flex';
        document.getElementById('hades-health-bar').style.display = 'flex';
        updatePlayerLivesUI();
        updateHadesHealthUI();
        
        // IMPORTANT: Set battle state immediately, don't wait for narration
        isInBattle = true;
        canAttack = true;
        canMove = true;
        
        console.log('Battle started! isInBattle:', isInBattle, 'enemies:', enemies.length, 'canAttack:', canAttack);
        
        showNarration("The dark portal transports me to the throne of the underworld...");
        showNarration("Everything I've done has been for this moment.");
        showNarration("HADES! YOUR REIGN OF TERROR ENDS NOW!", "Aeneas");
      });
    }
    
    // ============ COMBAT SYSTEM ============
    
    // Create a realistic skeleton warrior
    function createSkeletonWarrior() {
      const group = new THREE.Group();
      
      const boneMat = new THREE.MeshStandardMaterial({ 
        color: 0xd4c4a8, 
        roughness: 0.6,
        metalness: 0.1
      });
      const darkBoneMat = new THREE.MeshStandardMaterial({ 
        color: 0x8b7355, 
        roughness: 0.7 
      });
      
      // Pelvis
      const pelvisGeo = new THREE.BoxGeometry(0.6, 0.25, 0.3);
      const pelvis = new THREE.Mesh(pelvisGeo, boneMat);
      pelvis.position.y = 1;
      group.add(pelvis);
      
      // Spine (multiple vertebrae)
      for (let i = 0; i < 5; i++) {
        const vertebraGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 8);
        const vertebra = new THREE.Mesh(vertebraGeo, boneMat);
        vertebra.position.y = 1.2 + i * 0.2;
        group.add(vertebra);
      }
      
      // Ribcage
      for (let i = 0; i < 6; i++) {
        const ribGeo = new THREE.TorusGeometry(0.2 - i * 0.015, 0.03, 8, 16, Math.PI);
        const leftRib = new THREE.Mesh(ribGeo, boneMat);
        leftRib.position.set(-0.05, 1.4 + i * 0.12, 0.1);
        leftRib.rotation.y = Math.PI / 2;
        leftRib.rotation.z = -0.3;
        group.add(leftRib);
        
        const rightRib = new THREE.Mesh(ribGeo, boneMat);
        rightRib.position.set(0.05, 1.4 + i * 0.12, 0.1);
        rightRib.rotation.y = -Math.PI / 2;
        rightRib.rotation.z = 0.3;
        group.add(rightRib);
      }
      
      // Shoulders (clavicles)
      const clavicleGeo = new THREE.CapsuleGeometry(0.04, 0.3, 4, 8);
      const leftClavicle = new THREE.Mesh(clavicleGeo, boneMat);
      leftClavicle.position.set(-0.25, 2.1, 0);
      leftClavicle.rotation.z = Math.PI / 2.5;
      group.add(leftClavicle);
      
      const rightClavicle = new THREE.Mesh(clavicleGeo, boneMat);
      rightClavicle.position.set(0.25, 2.1, 0);
      rightClavicle.rotation.z = -Math.PI / 2.5;
      group.add(rightClavicle);
      
      // Arms (humerus, radius, ulna)
      function createArm(side) {
        const armGroup = new THREE.Group();
        const xMult = side === 'left' ? -1 : 1;
        
        // Humerus (upper arm)
        const humerusGeo = new THREE.CapsuleGeometry(0.05, 0.5, 4, 8);
        const humerus = new THREE.Mesh(humerusGeo, boneMat);
        humerus.position.set(xMult * 0.45, 1.8, 0);
        humerus.rotation.z = xMult * 0.3;
        armGroup.add(humerus);
        
        // Radius/Ulna (forearm)
        const forearmGeo = new THREE.CapsuleGeometry(0.04, 0.45, 4, 8);
        const forearm = new THREE.Mesh(forearmGeo, boneMat);
        forearm.position.set(xMult * 0.55, 1.35, 0.05);
        forearm.rotation.z = xMult * 0.2;
        armGroup.add(forearm);
        
        // Hand bones
        const handGeo = new THREE.BoxGeometry(0.12, 0.08, 0.05);
        const hand = new THREE.Mesh(handGeo, boneMat);
        hand.position.set(xMult * 0.6, 1.05, 0.05);
        armGroup.add(hand);
        
        // Fingers
        for (let f = 0; f < 4; f++) {
          const fingerGeo = new THREE.CapsuleGeometry(0.015, 0.08, 4, 6);
          const finger = new THREE.Mesh(fingerGeo, darkBoneMat);
          finger.position.set(xMult * (0.54 + f * 0.025), 0.98, 0.05);
          armGroup.add(finger);
        }
        
        return armGroup;
      }
      
      group.add(createArm('left'));
      group.add(createArm('right'));
      
      // Legs
      function createLeg(side) {
        const legGroup = new THREE.Group();
        const xMult = side === 'left' ? -1 : 1;
        
        // Femur (thigh)
        const femurGeo = new THREE.CapsuleGeometry(0.06, 0.6, 4, 8);
        const femur = new THREE.Mesh(femurGeo, boneMat);
        femur.position.set(xMult * 0.15, 0.5, 0);
        legGroup.add(femur);
        
        // Tibia/Fibula (shin)
        const tibiaGeo = new THREE.CapsuleGeometry(0.045, 0.55, 4, 8);
        const tibia = new THREE.Mesh(tibiaGeo, boneMat);
        tibia.position.set(xMult * 0.15, -0.1, 0.02);
        legGroup.add(tibia);
        
        // Foot
        const footGeo = new THREE.BoxGeometry(0.12, 0.05, 0.2);
        const foot = new THREE.Mesh(footGeo, boneMat);
        foot.position.set(xMult * 0.15, -0.4, 0.08);
        legGroup.add(foot);
        
        return legGroup;
      }
      
      group.add(createLeg('left'));
      group.add(createLeg('right'));
      
      // Skull
      const skullGroup = new THREE.Group();
      
      // Cranium
      const craniumGeo = new THREE.SphereGeometry(0.22, 16, 16);
      const cranium = new THREE.Mesh(craniumGeo, boneMat);
      cranium.position.y = 0.1;
      cranium.scale.set(0.85, 1, 0.9);
      skullGroup.add(cranium);
      
      // Jaw
      const jawGeo = new THREE.BoxGeometry(0.18, 0.08, 0.12);
      const jaw = new THREE.Mesh(jawGeo, boneMat);
      jaw.position.set(0, -0.12, 0.06);
      skullGroup.add(jaw);
      
      // Eye sockets (dark hollow)
      const eyeSocketMat = new THREE.MeshBasicMaterial({ color: 0x220022 });
      const eyeSocketGeo = new THREE.SphereGeometry(0.05, 8, 8);
      const leftEyeSocket = new THREE.Mesh(eyeSocketGeo, eyeSocketMat);
      leftEyeSocket.position.set(-0.08, 0.05, 0.15);
      skullGroup.add(leftEyeSocket);
      
      const rightEyeSocket = new THREE.Mesh(eyeSocketGeo, eyeSocketMat);
      rightEyeSocket.position.set(0.08, 0.05, 0.15);
      skullGroup.add(rightEyeSocket);
      
      // Glowing eyes
      const eyeGlowMat = new THREE.MeshBasicMaterial({ color: 0xff0044 });
      const eyeGlowGeo = new THREE.SphereGeometry(0.025, 8, 8);
      const leftEyeGlow = new THREE.Mesh(eyeGlowGeo, eyeGlowMat);
      leftEyeGlow.position.set(-0.08, 0.05, 0.16);
      skullGroup.add(leftEyeGlow);
      
      const rightEyeGlow = new THREE.Mesh(eyeGlowGeo, eyeGlowMat);
      rightEyeGlow.position.set(0.08, 0.05, 0.16);
      skullGroup.add(rightEyeGlow);
      
      // Nose hole
      const noseGeo = new THREE.ConeGeometry(0.03, 0.04, 3);
      const nose = new THREE.Mesh(noseGeo, eyeSocketMat);
      nose.position.set(0, -0.02, 0.18);
      nose.rotation.x = Math.PI;
      skullGroup.add(nose);
      
      // Teeth
      for (let t = 0; t < 6; t++) {
        const toothGeo = new THREE.BoxGeometry(0.025, 0.035, 0.02);
        const tooth = new THREE.Mesh(toothGeo, new THREE.MeshStandardMaterial({ color: 0xffffee }));
        tooth.position.set(-0.065 + t * 0.025, -0.08, 0.12);
        skullGroup.add(tooth);
      }
      
      skullGroup.position.y = 2.35;
      group.add(skullGroup);
      
      // Rusty sword
      const swordGroup = new THREE.Group();
      const bladeGeo = new THREE.BoxGeometry(0.08, 0.8, 0.02);
      const bladeMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8, metalness: 0.6 });
      const blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.y = 0.4;
      swordGroup.add(blade);
      
      const hiltGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8);
      const hiltMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
      const hilt = new THREE.Mesh(hiltGeo, hiltMat);
      swordGroup.add(hilt);
      
      const guardGeo = new THREE.BoxGeometry(0.15, 0.03, 0.03);
      const guard = new THREE.Mesh(guardGeo, bladeMat);
      guard.position.y = 0.05;
      swordGroup.add(guard);
      
      swordGroup.position.set(0.7, 1.1, 0.1);
      swordGroup.rotation.z = -0.4;
      group.add(swordGroup);
      
      // Metadata
      group.userData.isSkeleton = true;
      group.userData.health = 50;
      group.userData.maxHealth = 50;
      group.userData.speed = 2;
      
      // Health bar above skeleton
      const healthBarGroup = new THREE.Group();
      const healthBarBg = new THREE.Mesh(
        new THREE.PlaneGeometry(0.8, 0.1),
        new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
      );
      healthBarBg.position.y = 2.8;
      healthBarGroup.add(healthBarBg);
      
      const healthBarFill = new THREE.Mesh(
        new THREE.PlaneGeometry(0.78, 0.08),
        new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
      );
      healthBarFill.position.y = 2.8;
      healthBarFill.position.z = 0.01;
      healthBarGroup.add(healthBarFill);
      
      group.add(healthBarGroup);
      group.userData.healthBar = healthBarFill;
      group.userData.healthBarGroup = healthBarGroup;
      
      return group;
    }
    
    function spawnSkeletonWarrior() {
      const skeleton = createSkeletonWarrior();
      const angle = Math.random() * Math.PI * 2;
      const dist = 8 + Math.random() * 5;
      skeleton.position.set(
        Math.cos(angle) * dist,
        0,
        Math.sin(angle) * dist
      );
      skeleton.lookAt(0, 0, 0);
      scene.add(skeleton);
      sceneObjects.push(skeleton);
      skeletonWarriors.push(skeleton);
      enemies.push(skeleton);
      return skeleton;
    }
    
    function attack(type) {
      console.log('Attack called:', type, 'canAttack:', canAttack, 'isInBattle:', isInBattle, 'enemies:', enemies.length);
      
      if (!canAttack) {
        console.log('Attack blocked: canAttack is false');
        return;
      }
      
      // Allow attacks in battle OR if player has lightning bolt equipped
      if (!isInBattle && currentScene !== 'hades') {
        console.log('Attack blocked: not in battle mode');
        return;
      }
      
      canAttack = false;
      attackCooldown = 500;
      
      const damage = type === 'lightning' ? 35 : type === 'kick' ? 12 : type === 'punch' ? 8 : 15;
      console.log('Dealing damage:', damage, 'to', enemies.length, 'potential targets');
      
      // Check if hitting Hades
      enemies.forEach(enemy => {
        if (enemy.userData.isHades) {
          const dist = playerPos.distanceTo(enemy.position);
          console.log('Distance to Hades:', dist);
          if (dist < 8) { // Increased range from 6 to 8
            enemy.userData.health -= damage;
            hadesHealth = Math.max(0, enemy.userData.health);
            console.log('Hit Hades! Health now:', hadesHealth);
            playSound('hit');
            updateHadesHealthUI();
            
            // Hades knockback
            const dir = enemy.position.clone().sub(playerPos).normalize();
            enemy.position.add(dir.multiplyScalar(0.5));
            
            // Flash effect on Hades
            if (enemy.userData.aura) {
              enemy.userData.aura.material.opacity = 0.6;
              setTimeout(() => {
                if (enemy.userData.aura) enemy.userData.aura.material.opacity = 0.2;
              }, 100);
            }
            
            if (enemy.userData.health <= 0) {
              winGame();
            }
          }
        }
        
        // Check if hitting skeletons
        if (enemy.userData.isSkeleton) {
          const dist = playerPos.distanceTo(enemy.position);
          console.log('Distance to skeleton:', dist);
          if (dist < 4) { // Increased range from 3 to 4
            enemy.userData.health -= damage;
            console.log('Hit skeleton! Health now:', enemy.userData.health);
            playSound('hit');
            
            // Update skeleton health bar
            if (enemy.userData.healthBar) {
              const healthPercent = Math.max(0, enemy.userData.health / enemy.userData.maxHealth);
              enemy.userData.healthBar.scale.x = healthPercent;
              enemy.userData.healthBar.position.x = (1 - healthPercent) * -0.39;
            }
            
            if (enemy.userData.health <= 0) {
              scene.remove(enemy);
              skeletonWarriors = skeletonWarriors.filter(s => s !== enemy);
              enemies = enemies.filter(e => e !== enemy);
            }
          }
        }
      });
      
      // Arm animation (attack jab)
      if (playerHands && playerHands.userData.rightArm) {
        const arm = playerHands.userData.rightArm;
        arm.position.z -= 0.15;
        arm.rotation.x = -0.4;
        setTimeout(() => {
          arm.position.z += 0.15;
          arm.rotation.x = 0;
        }, 180);
      }
      
      setTimeout(() => {
        canAttack = true;
      }, attackCooldown);
    }
    
    function hadesAttack() {
      if (!isInBattle || hadesHealth <= 0) return;
      
      const hadesEntity = enemies.find(e => e.userData.isHades);
      const now = Date.now();
      
      // Skeleton spawning on a fixed 5-second timer (1 skeleton every 5 seconds)
      if (now - lastSkeletonSpawnTime >= skeletonSpawnInterval && skeletonWarriors.length < 5) {
        lastSkeletonSpawnTime = now;
        const skeleton = spawnSkeletonWarrior();
        if (skeleton) {
          console.log('Spawned skeleton warrior, total:', skeletonWarriors.length);
          showNarration("Hades summons a skeleton warrior!", "");
        }
      }
      
      // Other attacks (beam or ground slam)
      const attackType = Math.random();
      if (attackType < 0.5) {
        // Dark beam attack
        if (hadesEntity) {
          const beam = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 15, 8),
            new THREE.MeshBasicMaterial({ color: 0x8800ff, transparent: true, opacity: 0.8 })
          );
          beam.position.copy(hadesEntity.position);
          beam.position.y += 3;
          beam.lookAt(playerPos);
          beam.rotateX(Math.PI / 2);
          scene.add(beam);
          sceneObjects.push(beam);
          
          // Check if hit player - harder to dodge
          const dist = playerPos.distanceTo(hadesEntity.position);
          if (dist < 12) {
            takeDamage(30); // Increased damage
          }
          
          setTimeout(() => {
            scene.remove(beam);
            sceneObjects = sceneObjects.filter(o => o !== beam);
          }, 400);
        }
      } else {
        // Ground slam attack - damages player if too close
        if (hadesEntity) {
          const slam = new THREE.Mesh(
            new THREE.RingGeometry(0.5, 8, 32),
            new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
          );
          slam.rotation.x = -Math.PI / 2;
          slam.position.copy(hadesEntity.position);
          slam.position.y = 0.1;
          scene.add(slam);
          sceneObjects.push(slam);
          
          const dist = playerPos.distanceTo(hadesEntity.position);
          if (dist < 8) {
            takeDamage(35); // Heavy damage for close range
          }
          
          // Expand and fade
          let scale = 1;
          const slamInterval = setInterval(() => {
            scale += 0.3;
            slam.scale.setScalar(scale);
            slam.material.opacity -= 0.05;
            if (slam.material.opacity <= 0) {
              clearInterval(slamInterval);
              scene.remove(slam);
              sceneObjects = sceneObjects.filter(o => o !== slam);
            }
          }, 50);
          
          showNarration("Hades slams the ground!", "");
        }
      }
    }
    
    function takeDamage(amount = 25) {
      playerCurrentHealth -= amount;
      playSound('hit');
      
      // Red flash
      const overlay = document.getElementById('fade-overlay');
      overlay.style.background = '#ff0000';
      overlay.style.opacity = '0.4';
      setTimeout(() => {
        overlay.style.opacity = '0';
        overlay.style.background = '#000';
      }, 200);
      
      if (playerCurrentHealth <= 0) {
        // Lost one life
        lives--;
        playerCurrentHealth = playerMaxHealth;
        
        // Play death/bruh sound when losing a life
        playDeathSound();
      }
      
      updatePlayerLivesUI();
      
      if (lives <= 0) {
        gameOver();
      }
    }
    
    function gameOver() {
      // Play death sound on game over
      playDeathSound();
      
      // Reset boss fight
      lives = 3;
      playerCurrentHealth = playerMaxHealth;
      hadesHealth = 300; // Match increased HP
      lastSkeletonSpawnTime = 0; // Reset skeleton spawn timer
      const hadesEntity = enemies.find(e => e.userData.isHades);
      if (hadesEntity) {
        hadesEntity.userData.health = 300;
      }
      
      // Remove all skeletons
      skeletonWarriors.forEach(s => scene.remove(s));
      skeletonWarriors = [];
      enemies = enemies.filter(e => e.userData.isHades);
      
      // Reset position
      playerPos.set(0, 1.7, 10);
      camera.position.copy(playerPos);
      
      updatePlayerLivesUI();
      updateHadesHealthUI();
      
      showNarration("I cannot fall here... I must try again!");
    }
    
    let hadesDefeated = false;
    
    function winGame() {
      if (hadesDefeated) return;
      hadesDefeated = true;
      isInBattle = false;
      canMove = true;
      
      // Hide Hades health bar
      document.getElementById('hades-health-bar').style.display = 'none';
      document.getElementById('player-lives').style.display = 'none';
      
      // Remove Hades from scene
      enemies.forEach(e => {
        if (e.userData.isHades) {
          scene.remove(e);
        }
      });
      enemies = [];
      
      // Remove skeletons
      skeletonWarriors.forEach(s => scene.remove(s));
      skeletonWarriors = [];
      
      playBackgroundSound('olympus'); // Triumphant music
      
      showNarration("HADES IS DEFEATED!", "");
      showNarration("The souls of the dead cheer as the tyrant falls!");
      showNarration("His throne now stands empty... awaiting a new ruler.");
      
      setTimeout(() => {
        showNarration("The throne of the Underworld is yours for the taking...");
        document.getElementById('throne-sit-btn').style.display = 'block';
      }, 5000);
    }
    
    // Throne sit button handler
    document.getElementById('throne-sit-btn').addEventListener('click', () => {
      document.getElementById('throne-sit-btn').style.display = 'none';
      canMove = false;
      
      // Move player to throne position
      playerPos.set(0, 3, -6);
      camera.position.copy(playerPos);
      yaw = 0;
      pitch = -0.1;
      
      showNarration("I take my place upon the throne of the Underworld...");
      showNarration("I am now... RULER OF THE DEAD.", "");
      
      setTimeout(() => {
        // Fade to victory screen
        const victoryScreen = document.getElementById('victory-screen');
        victoryScreen.style.display = 'flex';
        
        setTimeout(() => {
          victoryScreen.classList.add('active');
          
          setTimeout(() => {
            victoryScreen.classList.add('show-text');
          }, 2000);
        }, 100);
      }, 4000);
    });
    
    // End game button handler
    document.getElementById('end-game-btn').addEventListener('click', () => {
      location.reload();
    });
    
    // ============ UI UPDATES ============
    function updateInventoryUI() {
      for (let i = 0; i < 3; i++) {
        const slot = document.getElementById(`slot-${i + 1}`);
        slot.innerHTML = `<span class="slot-num">${i + 1}</span>`;
        
        if (inventory[i] === 'lightning') {
          slot.innerHTML += '‚ö°';
        } else if (inventory[i] === 'coin') {
          slot.innerHTML += 'ü™ô';
        }
        
        slot.classList.toggle('active', i === selectedSlot);
      }
    }
    
    function updatePlayerLivesUI() {
      for (let i = 1; i <= 3; i++) {
        const lifeContainer = document.getElementById(`life-${i}`);
        const lifeFill = document.getElementById(`life-fill-${i}`);
        
        if (i < lives) {
          // Full life
          lifeContainer.classList.remove('lost');
          lifeFill.style.width = '100%';
        } else if (i === lives) {
          // Current life being used
          lifeContainer.classList.remove('lost');
          lifeFill.style.width = (playerCurrentHealth / playerMaxHealth * 100) + '%';
        } else {
          // Lost life
          lifeContainer.classList.add('lost');
          lifeFill.style.width = '0%';
        }
      }
    }
    
    function updateHadesHealthUI() {
      const healthFill = document.getElementById('hades-health-fill');
      const healthText = document.getElementById('hades-health-text');
      const maxHealth = 300;
      if (healthFill) healthFill.style.width = (hadesHealth / maxHealth * 100) + '%';
      if (healthText) healthText.textContent = Math.max(0, Math.round(hadesHealth));
    }
    
    function updateLivesUI() {
      // Compatibility function - calls new UI updater
      updatePlayerLivesUI();
    }
    
    // ============ INPUT HANDLING ============
    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      
      if (e.code === 'Digit1') { selectedSlot = 0; updateInventoryUI(); updateHeldItem(); }
      if (e.code === 'Digit2') { selectedSlot = 1; updateInventoryUI(); updateHeldItem(); }
      if (e.code === 'Digit3') { selectedSlot = 2; updateInventoryUI(); updateHeldItem(); }
      
      if (e.code === 'KeyE') {
        if (isDialogueOpen) {
          advanceDialogue();
        } else if (isInBattle || currentScene === 'hades') {
          // PC combat: E swings weapon
          attack(inventory[selectedSlot] || 'melee');
        } else {
          tryInteract();
        }
      }
      
      if (e.code === 'Space' && isInBattle) {
        attack(inventory[selectedSlot] || 'melee');
      }
    });
    
    document.addEventListener('keyup', e => {
      keys[e.code] = false;
    });
    
    // Mouse look
    document.addEventListener('mousemove', e => {
      if (document.pointerLockElement === renderer.domElement && canLook) {
        yaw -= e.movementX * 0.002;
        pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch - e.movementY * 0.002));
      }
    });
    
    renderer.domElement.addEventListener('click', () => {
      if (!isMobile && gameState === 'playing') {
        if (document.pointerLockElement !== renderer.domElement) {
          renderer.domElement.requestPointerLock();
        } else {
          // Pointer is locked - handle interactions
          if (isDialogueOpen) {
            advanceDialogue();
          } else if (isInBattle || currentScene === 'hades') {
            // Attack when in battle OR in hades scene (PC fix)
            attack(inventory[selectedSlot] || 'melee');
          }
        }
      }
    });

    // PC combat: right-click swings weapon (robust: works anywhere on screen)
    let pendingAttackOnPointerLock = false;

    function canHandleCombatInput() {
      if (isMobile) return false;
      if (gameState !== 'playing') return false;
      if (isPaused) return false;
      if (portalPasswordActive) return false;
      return (isInBattle || currentScene === 'hades');
    }

    function performCombatAttack() {
      attack(inventory[selectedSlot] || 'melee');
    }

    // Prevent the browser context menu from ever stealing right-click
    document.addEventListener('contextmenu', (e) => {
      if (!isMobile && gameState === 'playing') e.preventDefault();
    }, { capture: true });

    // If we requested pointer lock via right-click, attack immediately once locked
    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === renderer.domElement && pendingAttackOnPointerLock) {
        pendingAttackOnPointerLock = false;
        if (canHandleCombatInput()) performCombatAttack();
      }
    });

    // Use a document-level handler so "right click anywhere" works (not just on the canvas)
    document.addEventListener('mousedown', (e) => {
      if (e.button !== 2) return;
      if (!canHandleCombatInput()) return;
      e.preventDefault();

      if (document.pointerLockElement !== renderer.domElement) {
        pendingAttackOnPointerLock = true;
        renderer.domElement.requestPointerLock();
        return;
      }

      if (isDialogueOpen) {
        advanceDialogue();
      } else {
        performCombatAttack();
      }
    }, { capture: true });
    
    // Mobile controls - track multiple touch points independently
    let lookTouchId = null;
    let joystickTouchId = null;
    let lastTouchX = 0, lastTouchY = 0;
    
    // Separate touch handlers for joystick zone and look area
    const joystickZone = document.getElementById('joystick-zone');
    const lookArea = document.getElementById('look-area');
    
    // Joystick touch handling
    joystickZone.addEventListener('touchstart', e => {
      if (gameState !== 'playing') return;
      e.stopPropagation();
      
      const touch = e.changedTouches[0];
      if (joystickTouchId === null) {
        joystickTouchId = touch.identifier;
        const rect = document.getElementById('move-joystick').getBoundingClientRect();
        joystickCenter.x = rect.left + rect.width / 2;
        joystickCenter.y = rect.top + rect.height / 2;
        handleJoystickTouch(touch);
      }
    }, { passive: false });
    
    joystickZone.addEventListener('touchmove', e => {
      if (gameState !== 'playing') return;
      e.stopPropagation();
      e.preventDefault();
      
      for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
          handleJoystickTouch(touch);
        }
      }
    }, { passive: false });
    
    joystickZone.addEventListener('touchend', e => {
      e.stopPropagation();
      for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
          joystickTouchId = null;
          joystickInput.x = 0;
          joystickInput.y = 0;
          joystickKnob.style.transform = 'translate(-50%, -50%)';
        }
      }
    }, { passive: true });
    
    // Look area touch handling (rest of the screen)
    lookArea.addEventListener('touchstart', e => {
      if (gameState !== 'playing') return;
      
      const touch = e.changedTouches[0];
      // Make sure we're not on action buttons
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      if (el && el.closest('#action-buttons')) return;
      
      if (lookTouchId === null) {
        lookTouchId = touch.identifier;
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
      }
    }, { passive: true });
    
    lookArea.addEventListener('touchmove', e => {
      if (gameState !== 'playing') return;
      
      for (let touch of e.changedTouches) {
        if (touch.identifier === lookTouchId && canLook) {
          const dx = touch.clientX - lastTouchX;
          const dy = touch.clientY - lastTouchY;
          yaw -= dx * 0.008;
          pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch - dy * 0.008));
          lastTouchX = touch.clientX;
          lastTouchY = touch.clientY;
        }
      }
    }, { passive: true });
    
    lookArea.addEventListener('touchend', e => {
      for (let touch of e.changedTouches) {
        if (touch.identifier === lookTouchId) {
          lookTouchId = null;
        }
      }
    }, { passive: true });
    
    function handleJoystickTouch(touch) {
      const dx = touch.clientX - joystickCenter.x;
      const dy = touch.clientY - joystickCenter.y;
      const dist = Math.min(50, Math.sqrt(dx * dx + dy * dy));
      const angle = Math.atan2(dy, dx);
      
      // Full 2D movement on joystick (forward/back + strafe)
      joystickInput.x = (dist / 50) * Math.cos(angle);
      joystickInput.y = (dist / 50) * Math.sin(angle);
      
      const knobX = (dist / 50) * 35 * Math.cos(angle);
      const knobY = (dist / 50) * 35 * Math.sin(angle);
      joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
    }
    
    // Joystick elements and state
    const joystickKnob = document.getElementById('joystick-knob');
    let joystickCenter = { x: 0, y: 0 };
    
    // Mobile action buttons
    document.getElementById('btn-jump').addEventListener('touchstart', e => {
      e.preventDefault();
      if (isGrounded) {
        playerVel.y = 8;
        isGrounded = false;
      }
    });
    
    document.getElementById('btn-attack').addEventListener('touchstart', e => {
      e.preventDefault();
      if (isInBattle) attack(inventory[selectedSlot] || 'melee');
    });
    
    document.getElementById('btn-kick').addEventListener('touchstart', e => {
      e.preventDefault();
      if (isInBattle) attack('kick');
    });
    
    document.getElementById('btn-punch').addEventListener('touchstart', e => {
      e.preventDefault();
      if (isInBattle) attack('punch');
    });
    
    document.getElementById('btn-interact').addEventListener('touchstart', e => {
      e.preventDefault();
      if (isDialogueOpen) advanceDialogue();
      else tryInteract();
    });
    
    // Narrator box click
    document.getElementById('narrator-box').addEventListener('click', e => {
      e.stopPropagation();
      advanceDialogue();
    });
    
    document.getElementById('narrator-box').addEventListener('touchend', e => {
      e.preventDefault();
      e.stopPropagation();
      advanceDialogue();
    });
    
    // Body switch menu
    document.getElementById('body-perseus').addEventListener('click', switchToPerseus);
    document.getElementById('body-perseus').addEventListener('touchend', e => {
      e.preventDefault();
      switchToPerseus();
    });
    
    // ============ INTERACTION ============
    function tryInteract() {
      // Boss portal now auto-triggers when stepping under it (see checkAutoTriggers)
      
      // Check for Charon
      if (currentScene === 'styx') {
        const charonDist = playerPos.distanceTo(new THREE.Vector3(0, 0, 10));
        if (charonDist < 8) {
          payCharon();
          return;
        }
      }
      
      // Check for puzzle orbs
      if (currentScene === 'puzzle') {
        puzzleOrbs.forEach(orb => {
          const dist = playerPos.distanceTo(orb.position);
          if (dist < 3) {
            collectOrb(orb.userData.orbIndex);
          }
        });
        
        // Check for coin
        interactables.forEach(obj => {
          if (obj.userData.isCoin) {
            const dist = playerPos.distanceTo(obj.position);
            if (dist < 3) {
              scene.remove(obj);
              collectCoin();
            }
          }
        });
      }
    }
    
    // Automatic scene triggers based on position
    let sceneTransitioning = false;
    
    function checkAutoTriggers() {
      if (sceneTransitioning) return;
      
      // Mortal realm -> Boss portal (automatic teleport when stepping under portal)
      // Portal is at z=20, player stepping close triggers password UI
      if (currentScene === 'mortal') {
        const portalPos = new THREE.Vector3(0, 1.7, 20);
        const portalDist = playerPos.distanceTo(portalPos);
        if (portalDist < 4) { // Auto-trigger when close to portal
          sceneTransitioning = true;
          showPortalPasswordUI();
          return;
        }
      }
      
      // Mortal realm -> Staircase scene (when climbing high on stairs)
      // Staircase starts at z=-30, 80 steps at 1.8 run each = -174 total
      // Trigger when past step 60 (z < -138) and high enough (y > 8)
      if (currentScene === 'mortal' && playerPos.z < -130 && playerPos.y > 7) {
        sceneTransitioning = true;
        enterStaircase();
        setTimeout(() => sceneTransitioning = false, 2000);
        return;
      }
      
      // Staircase -> Fortress (when reaching near top)
      // 150 steps at 0.15 rise = max height 22.5, trigger at y > 19
      if (currentScene === 'staircase' && playerPos.y > 19) {
        sceneTransitioning = true;
        enterFortress();
        setTimeout(() => sceneTransitioning = false, 2000);
        return;
      }
      
      // Olympus -> Meet Zeus (when walking close to throne)
      if (currentScene === 'olympus' && playerPos.z < -38 && !zeusMet) {
        sceneTransitioning = true;
        meetZeus();
        setTimeout(() => sceneTransitioning = false, 2000);
        return;
      }
    }
    
    // ============ GAME LOOP ============
    let lastTime = performance.now();
    let hadesAttackTimer = 0;
    
    function gameLoop() {
      const now = performance.now();
      const delta = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;
      
      if (gameState !== 'playing') {
        renderer.render(scene, camera);
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Camera rotation with WASD
      if (canLook) {
        const rotSpeed = 2 * delta;
        if (keys['KeyW']) pitch = Math.min(Math.PI / 2 - 0.1, pitch + rotSpeed);
        if (keys['KeyS']) pitch = Math.max(-Math.PI / 2 + 0.1, pitch - rotSpeed);
        if (keys['KeyA']) yaw += rotSpeed;
        if (keys['KeyD']) yaw -= rotSpeed;
      }
      
      // Movement with Arrow keys
      if (canMove) {
        let moveX = 0, moveZ = 0;
        
        if (keys['ArrowUp']) moveZ = -1;
        if (keys['ArrowDown']) moveZ = 1;
        if (keys['ArrowLeft']) moveX = -1;
        if (keys['ArrowRight']) moveX = 1;
        
        // Joystick
        moveX += joystickInput.x;
        moveZ += joystickInput.y;
        
        // Sprint
        isSprinting = keys['ShiftLeft'] || keys['ShiftRight'];
        const speed = isSprinting ? 8 : 5;
        
        // Calculate movement direction
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        right.y = 0;
        right.normalize();
        
        const moveDir = forward.multiplyScalar(-moveZ).add(right.multiplyScalar(moveX));
        if (moveDir.length() > 0) {
          moveDir.normalize();
          playerVel.x = moveDir.x * speed;
          playerVel.z = moveDir.z * speed;
        } else {
          // keep tiny drift zeroed so you don't keep creeping forward
          playerVel.x = 0;
          playerVel.z = 0;
        }
        
        // Jump (Space only)
        if (keys['Space'] && isGrounded && !isInBattle) {
          playerVel.y = 8;
          isGrounded = false;
        }
      } else {
        playerVel.x *= 0.9;
        playerVel.z *= 0.9;
      }
      
      // Gravity
      playerVel.y -= 20 * delta;
      
      // Apply velocity
      playerPos.add(playerVel.clone().multiplyScalar(delta));
      
      // Ground collision with proper staircase steps
      let groundY = 0;
      
      if (currentScene === 'staircase') {
        // In staircase scene, steps are at z = -i * stairRun, y = i * stairRise
        const stepRise = 0.15;
        const stepRun = 1.8;
        const distFromStart = -playerPos.z;
        if (distFromStart >= 0) {
          const stepIndex = Math.floor(distFromStart / stepRun);
          if (stepIndex >= 0 && stepIndex < 150) {
            // Keep feet fully on top: groundY is the top surface of the step
            groundY = stepIndex * stepRise;
          }
        } else {
          groundY = 0;
        }
        
        // Side barriers - prevent falling off
        if (playerPos.x < -1.8) playerPos.x = -1.8;
        if (playerPos.x > 1.8) playerPos.x = 1.8;
        
        // Prevent going backwards
        if (playerPos.z > 2) playerPos.z = 2;
        
      } else if (currentScene === 'mortal') {
        groundY = 0;
        
        // Check if player is on the floating staircase in mortal realm
        // Staircase is at z = -30, steps go in -z direction
        const stairStartZ = -30;
        const stairWidth = 1.8;
        const stepRise = 0.15;
        const stepRun = 1.8;
        
        if (playerPos.z < stairStartZ && Math.abs(playerPos.x) < stairWidth) {
          // Calculate how far into the staircase we are
          const distFromStart = stairStartZ - playerPos.z; // positive value
          if (distFromStart > 0) {
            const stepIndex = Math.floor(distFromStart / stepRun);
            if (stepIndex >= 0 && stepIndex < 80) {
              // Top of the step is groundY
              groundY = stepIndex * stepRise;
              
              // Side barriers on staircase
              if (playerPos.x < -1.6) playerPos.x = -1.6;
              if (playerPos.x > 1.6) playerPos.x = 1.6;
            }
          }
        }
        
        // Keep player in bounds of mortal realm
        if (playerPos.x < -40) playerPos.x = -40;
        if (playerPos.x > 40) playerPos.x = 40;
        if (playerPos.z > 40) playerPos.z = 40;
      }
      
      if (playerPos.y < groundY + 1.7) {
        playerPos.y = groundY + 1.7;
        playerVel.y = 0;
        isGrounded = true;
      }
      
      // Update camera
      camera.position.copy(playerPos);
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      
      // Hades and Skeleton AI - faster attack rate
      if (isInBattle && enemies.length > 0 && hadesHealth > 0) {
        hadesAttackTimer += delta;
        // Faster attacks - every 1.5 seconds instead of 2.5
        if (hadesAttackTimer > 1.5) {
          hadesAttackTimer = 0;
          hadesAttack();
        }
        
        // Hades looks at player
        enemies.forEach(enemy => {
          if (enemy.userData.isHades) {
            enemy.lookAt(playerPos.x, enemy.position.y, playerPos.z);
            
            // Aura pulse
            if (enemy.userData.aura) {
              enemy.userData.aura.scale.setScalar(1 + Math.sin(now * 0.003) * 0.1);
            }
          }
          
          // Skeleton AI - chase and attack player
          if (enemy.userData.isSkeleton) {
            const distToPlayer = enemy.position.distanceTo(playerPos);
            
            // Look at player
            enemy.lookAt(playerPos.x, enemy.position.y, playerPos.z);
            
            // Make health bar face camera
            if (enemy.userData.healthBarGroup) {
              enemy.userData.healthBarGroup.lookAt(camera.position);
            }
            
            // Move towards player if not too close
            if (distToPlayer > 2) {
              const dir = playerPos.clone().sub(enemy.position).normalize();
              dir.y = 0;
              enemy.position.add(dir.multiplyScalar(enemy.userData.speed * delta));
            } else if (distToPlayer <= 2) {
              // Attack player
              if (!enemy.userData.attackCooldown) {
                enemy.userData.attackCooldown = true;
                takeDamage(15);
                setTimeout(() => {
                  if (enemy.userData) enemy.userData.attackCooldown = false;
                }, 2000);
              }
            }
            
            // Skeleton walk animation
            enemy.position.y = Math.sin(now * 0.01) * 0.05;
          }
        });
      }
      
      // Animate ghosts
      sceneObjects.forEach(obj => {
        if (obj.userData.isGhost) {
          obj.position.y = Math.sin(now * 0.001 + obj.position.x) * 0.35 + 0.05;
          obj.rotation.y += delta * 0.35;
        }
      });
      
      // Animate puzzle orbs
      puzzleOrbs.forEach(orb => {
        orb.rotation.y += delta * 2;
        orb.position.y = 1.5 + Math.sin(now * 0.003) * 0.3;
      });
      
      // Check automatic scene triggers
      checkAutoTriggers();
      
      // Auto-trigger Charon payment when very close with coin
      if (currentScene === 'styx' && inventory[1] === 'coin') {
        const charonDist = playerPos.distanceTo(new THREE.Vector3(0, 0, 10));
        if (charonDist < 4) {
          payCharon();
        }
      }
      
      // Fortress-specific triggers
      if (currentScene === 'fortress') {
        checkFortressTrigger();
        checkFortressEntry();
      }

      // Hand swing animation when moving
      if (playerHands) {
        const moving = Math.abs(playerVel.x) + Math.abs(playerVel.z) > 0.2;
        const leftHand = playerHands.userData.leftHand;
        const rightHand = playerHands.userData.rightHand;
        const leftBase = playerHands.userData.leftBase;
        const rightBase = playerHands.userData.rightBase;
        const leftBaseRot = playerHands.userData.leftBaseRot;
        const rightBaseRot = playerHands.userData.rightBaseRot;
        
        if (leftHand && rightHand && leftBase && rightBase && leftBaseRot && rightBaseRot) {
          if (moving) {
            playerHands.userData.swingPhase += delta * 10;
            const swing = Math.sin(playerHands.userData.swingPhase) * 0.08;
            const bob = Math.abs(Math.sin(playerHands.userData.swingPhase * 2)) * 0.015;
            
            // Edge hand swing (stay at corners)
            leftHand.position.set(
              leftBase.x,
              leftBase.y + bob,
              leftBase.z + swing
            );
            rightHand.position.set(
              rightBase.x,
              rightBase.y + bob,
              rightBase.z - swing
            );
            
            leftHand.rotation.x = leftBaseRot.x + swing * 0.3;
            rightHand.rotation.x = rightBaseRot.x - swing * 0.3;
          } else {
            // Smoothly return to rest
            leftHand.position.lerp(leftBase, 0.12);
            rightHand.position.lerp(rightBase, 0.12);
            leftHand.rotation.x += (leftBaseRot.x - leftHand.rotation.x) * 0.12;
            rightHand.rotation.x += (rightBaseRot.x - rightHand.rotation.x) * 0.12;
          }
        }
      }
      
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }
    
    // ============ MENU HANDLERS ============
    function selectPC() {
      isMobile = false;
      document.getElementById('btn-pc').classList.add('active');
      document.getElementById('btn-mobile').classList.remove('active');
      document.getElementById('controls-hint').textContent = 'Arrow Keys to move ‚Ä¢ WASD to look around ‚Ä¢ Space to jump/attack ‚Ä¢ E to interact';
    }
    
    function selectMobile() {
      isMobile = true;
      document.getElementById('btn-mobile').classList.add('active');
      document.getElementById('btn-pc').classList.remove('active');
      document.getElementById('controls-hint').textContent = 'Joystick to move ‚Ä¢ Drag to look ‚Ä¢ Buttons for actions';
    }
    
    function beginGame() {
      console.log('BEGIN GAME CLICKED');
      try {
        document.getElementById('title-screen').style.display = 'none';
        
        if (isMobile) {
          document.getElementById('mobile-controls').style.display = 'block';
        }
        
        startGame();
      } catch (error) {
        console.error('Error starting game:', error);
        alert('Error starting game: ' + error.message);
      }
    }
    
    // Add both click and touch handlers
    const btnPC = document.getElementById('btn-pc');
    const btnMobile = document.getElementById('btn-mobile');
    const btnStart = document.getElementById('btn-start');
    
    btnPC.addEventListener('click', selectPC);
    btnPC.addEventListener('touchend', (e) => { e.preventDefault(); selectPC(); });
    
    btnMobile.addEventListener('click', selectMobile);
    btnMobile.addEventListener('touchend', (e) => { e.preventDefault(); selectMobile(); });
    
    btnStart.addEventListener('click', beginGame);
    btnStart.addEventListener('touchend', (e) => { e.preventDefault(); beginGame(); });
    
    // Auto-detect mobile
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      document.getElementById('btn-mobile').click();
    }
    
    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Start render loop
    gameLoop();

    // ============ ESCAPE ROOM PUZZLE SYSTEM ============
    const escapeState = {
        currentRoom: 1,
        inventory: [],
        selectedItem: null,
        rooms: {
            1: { name: "The Study", doorUnlocked: false, cabinetOpen: false, keyCollected: false, chestOpen: false, ventOpen: false, wireCollected: false },
            2: { name: "The Laboratory", doorUnlocked: false, powerOn: false, leverPulled: false, fuseInserted: false, wireInserted: false, wirePaired: false, safeOpen: false, codeFound: false, greenKeyCollected: false, screwdriverCollected: false, fuseCollected: false, lockerOpen: false, wireCollected: false },
            3: { name: "The Exit", orbsPlaced: { red: false, blue: false, green: false } }
        }
    };

    const escapeRoomHints = {
        1: [
            "Look around the room - there's a cabinet on the left wall.",
            "Open the cabinet to find the brass key inside.",
            "The note on the back wall has the chest code hint: 2 + ? = 6.",
            "The chest code is 24 (first digit 2, second digit 4).",
            "Use the screwdriver from Room 2 to open the vent; crawl through to find a wire.",
            "Use the brass key on the door to go to Room 2."
        ],
        2: [
            "Pick up the fuse on the right-side shelf.",
            "Pick up the screwdriver on the left-side shelf.",
            "Crawl through the Room 1 vent to grab the loose wire, then insert fuse + wire into the power box.",
            "After inserting wire you'll get a popup to connect colored wires; then pull the lever on the left wall.",
            "The keypad code is 1987 - check the note on the left wall.",
            "Use the green key (from keypad) on the safe to get the blue orb."
        ],
        3: [
            "You need all three orbs to escape.",
            "Red orb: Room 1's chest (code 24).",
            "Blue orb: Room 2's safe (green key).",
            "Green orb: Appears in Room 2 after solving the keypad.",
            "Select an orb from inventory, then click its pedestal.",
            "Place all 3 orbs to obtain the coin!"
        ]
    };

    let escapeCurrentHintIndex = 0;
    let escapeCurrentRotationY = 0;
    let escapeCurrentRotationX = 0;
    let escapeDraggingWire = null;

    function startEscapeRoom() {
        // Show escape room container
        document.getElementById('escape-room-container').style.display = 'block';
        
        // Reset state
        escapeState.currentRoom = 1;
        escapeState.inventory = [];
        escapeState.selectedItem = null;
        escapeState.rooms = {
            1: { name: "The Study", doorUnlocked: false, cabinetOpen: false, keyCollected: false, chestOpen: false, ventOpen: false, wireCollected: false },
            2: { name: "The Laboratory", doorUnlocked: false, powerOn: false, leverPulled: false, fuseInserted: false, wireInserted: false, wirePaired: false, safeOpen: false, codeFound: false, greenKeyCollected: false, screwdriverCollected: false, fuseCollected: false, lockerOpen: false, wireCollected: false },
            3: { name: "The Exit", orbsPlaced: { red: false, blue: false, green: false } }
        };
        escapeCurrentHintIndex = 0;
        escapeCurrentRotationY = 0;
        escapeCurrentRotationX = 0;
        
        // Create particles
        escapeCreateParticles();
        
        // Setup cursor
        const escapeCursor = document.getElementById('escape-cursor');
        document.addEventListener('mousemove', (e) => {
            escapeCursor.style.left = e.clientX + 'px';
            escapeCursor.style.top = e.clientY + 'px';
        });
        
        // Setup room rotation
        const escapeContainer = document.getElementById('escapeGameContainer');
        escapeContainer.addEventListener('mousemove', (e) => {
            const centerX = window.innerWidth / 2, centerY = window.innerHeight / 2;
            const targetY = ((e.clientX - centerX) / centerX) * 90;
            const targetX = ((centerY - e.clientY) / centerY) * 18;
            escapeCurrentRotationY += (targetY - escapeCurrentRotationY) * 0.08;
            escapeCurrentRotationX += (targetX - escapeCurrentRotationX) * 0.08;
            const room = document.getElementById('escapeRoom');
            if (room) { room.style.transform = `rotateX(${escapeCurrentRotationX}deg) rotateY(${escapeCurrentRotationY}deg)`; }
            document.getElementById('escapeCompassArrow').style.transform = `rotate(${-escapeCurrentRotationY}deg)`;
            escapeUpdateRoomLabel(escapeCurrentRotationY);
        });
        
        // Render first room
        escapeRenderRoom(1);
        
        setTimeout(() => {
            escapeShowMessage("üîÆ Perseus's Trial begins! Explore Room 1. Look left to find the cabinet!");
        }, 500);
    }

    function escapeCreateParticles() {
        const c = document.getElementById('escape-particles');
        c.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const p = document.createElement('div');
            p.className = 'escape-particle';
            p.style.left = Math.random() * 100 + '%';
            p.style.animationDelay = Math.random() * 15 + 's';
            p.style.opacity = Math.random() * 0.4 + 0.1;
            c.appendChild(p);
        }
    }

    function escapeUpdateRoomLabel(rotation) {
        const label = document.getElementById('escapeRoomLabel');
        let facing = '';
        if (rotation > -35 && rotation < 35) facing = 'Back Wall';
        else if (rotation >= 35) facing = 'Left Wall';
        else if (rotation <= -35) facing = 'Right Wall';
        label.textContent = `Facing: ${facing}`;
    }

    function escapeAddToInventory(id, emoji, name) {
        if (escapeState.inventory.find(i => i.id === id)) return false;
        const used = escapeState.inventory.map(i => i.slot);
        let slot = -1;
        for (let s = 0; s < 6; s++) {
            if (!used.includes(s)) { slot = s; break; }
        }
        if (slot === -1) return false;
        const item = { id, emoji, name, slot };
        escapeState.inventory.push(item);
        const el = document.getElementById('escapeSlot' + slot);
        el.textContent = emoji;
        el.classList.add('filled');
        el.title = name;
        escapeShowMessage(`‚ú® Collected: ${name}`);
        return true;
    }

    function escapeHasItem(id) {
        return escapeState.inventory.some(i => i.id === id);
    }

    function escapeRemoveItem(id) {
        const idx = escapeState.inventory.findIndex(i => i.id === id);
        if (idx === -1) return;
        const item = escapeState.inventory[idx];
        const el = document.getElementById('escapeSlot' + item.slot);
        el.textContent = '';
        el.classList.remove('filled', 'selected');
        escapeState.inventory.splice(idx, 1);
        escapeState.selectedItem = null;
        document.getElementById('escapeUseItemHint').style.display = 'none';
        document.getElementById('escape-cursor').classList.remove('using-item');
    }

    function escapeSelectInventorySlot(slot) {
        const item = escapeState.inventory.find(i => i.slot === slot);
        if (!item) return;
        document.querySelectorAll('.escape-inv-slot').forEach(s => s.classList.remove('selected'));
        if (escapeState.selectedItem === item.id) {
            escapeState.selectedItem = null;
            document.getElementById('escapeUseItemHint').style.display = 'none';
            document.getElementById('escape-cursor').classList.remove('using-item');
        } else {
            escapeState.selectedItem = item.id;
            document.getElementById('escapeSlot' + slot).classList.add('selected');
            document.getElementById('escapeUseItemHint').textContent = `Using: ${item.name} - Click on target`;
            document.getElementById('escapeUseItemHint').style.display = 'block';
            document.getElementById('escape-cursor').classList.add('using-item');
        }
    }

    function escapeCleanupFloatingItems() {
        document.querySelectorAll('.escape-floating-item').forEach(el => el.remove());
    }

    function escapeSpawnFloatingItem(id, emoji, label, left, top, onClick) {
        if (document.getElementById(id)) return;
        const el = document.createElement('div');
        el.className = 'escape-floating-item';
        el.id = id;
        el.style.cssText = `left:${left}; top:${top};`;
        el.innerHTML = `${emoji}<span class="label">${label}</span>`;
        el.onclick = onClick;
        el.addEventListener('mouseenter', () => document.getElementById('escape-cursor').classList.add('hovering'));
        el.addEventListener('mouseleave', () => document.getElementById('escape-cursor').classList.remove('hovering'));
        document.getElementById('escape-room-container').appendChild(el);
    }

    function escapeRenderRoom(roomNum) {
        escapeCleanupFloatingItems();
        const room = document.getElementById('escapeRoom');
        room.className = `room room-${roomNum}`;
        document.getElementById('escapeRoomIndicator').textContent = `Room ${roomNum} of 3: ${escapeState.rooms[roomNum].name}`;
        let html = `<div class="wall floor"></div><div class="wall ceiling"></div>`;
        if (roomNum === 1) html += escapeRenderRoom1();
        else if (roomNum === 2) html += escapeRenderRoom2();
        else if (roomNum === 3) html += escapeRenderRoom3();
        room.innerHTML = html;
        escapeSetupInteractiveElements();
        setTimeout(() => escapeSpawnFloatingItemsForRoom(roomNum), 100);
    }

    function escapeSpawnFloatingItemsForRoom(roomNum) {
        if (roomNum === 2) {
            const s = escapeState.rooms[2];
            if (!s.screwdriverCollected && !escapeHasItem('screwdriver')) {
                escapeSpawnFloatingItem('floatingScrewdriver', 'ü™õ', 'Screwdriver', '18%', '42%', () => {
                    if (escapeAddToInventory('screwdriver', 'ü™õ', 'Screwdriver')) {
                        s.screwdriverCollected = true;
                        document.getElementById('floatingScrewdriver')?.remove();
                    }
                });
            }
            if (!s.fuseCollected && !escapeHasItem('fuse')) {
                escapeSpawnFloatingItem('floatingFuse', 'üîå', 'Fuse', '32%', '42%', () => {
                    if (escapeAddToInventory('fuse', 'üîå', 'Fuse')) {
                        s.fuseCollected = true;
                        document.getElementById('floatingFuse')?.remove();
                    }
                });
            }
            if (escapeState.rooms[1].ventOpen && !escapeHasItem('wire') && !s.wireCollected) {
                escapeSpawnFloatingItem('floatingWire', 'üßµ', 'Loose Wire', '75%', '55%', () => {
                    if (escapeAddToInventory('wire', 'üßµ', 'Loose Wire')) {
                        s.wireCollected = true;
                        document.getElementById('floatingWire')?.remove();
                    }
                });
                escapeShowMessage("üßµ Found the loose wire behind the vent! Grab it to power the lab.");
            }
            if (s.codeFound && !s.greenKeyCollected) {
                escapeSpawnFloatingItem('floatingGreenKey', 'üóùÔ∏è', 'Green Key', '70%', '45%', () => {
                    if (escapeAddToInventory('green_key', 'üóùÔ∏è', 'Green Key')) {
                        s.greenKeyCollected = true;
                        document.getElementById('floatingGreenKey')?.remove();
                    }
                });
            }
            if (s.codeFound && !escapeHasItem('green_orb') && !escapeState.rooms[3].orbsPlaced.green) {
                escapeSpawnFloatingItem('floatingGreenOrb', 'üü¢', 'Green Orb', '75%', '60%', () => {
                    if (escapeAddToInventory('green_orb', 'üü¢', 'Green Orb')) {
                        document.getElementById('floatingGreenOrb')?.remove();
                    }
                });
            }
        }
    }

    function escapeRenderRoom1() {
        const state = escapeState.rooms[1];
        return `
            <div class="wall back-wall">
                <div class="door ${state.doorUnlocked ? 'unlocked' : 'locked'} interactive" data-action="door1">üö™</div>
                <div class="note interactive" style="right: 12%; top: 18%;" data-action="note1">The chest remembers:<br>üî∫ + üî∫ = 6<br>The first is 2...</div>
                <div class="painting interactive" style="left: 12%; top: 12%;" data-action="painting">üñºÔ∏è</div>
                <div class="vent ${state.ventOpen ? 'open' : 'closed'} interactive" style="right: 8%; bottom: 100px;" data-action="vent1">${Array(12).fill('<div class="vent-slat"></div>').join('')}</div>
            </div>
            <div class="wall left-wall">
                <div class="cabinet interactive ${state.cabinetOpen ? 'shelves-open' : ''}" style="left: 25%; top: 28%;" data-action="cabinet1">
                    <div class="cabinet-door">${state.cabinetOpen ? 'üì≠' : 'üö™'}</div>
                    <div class="cabinet-door">üì¶</div>
                    ${state.cabinetOpen && !state.keyCollected ? `<div class="escape-floating-item" style="position:absolute; left:50%; top:55%; transform:translate(-50%,-50%); animation:none; z-index:600;" data-action="collectKeyInCabinet">üîë<span class="label">Brass Key</span></div>` : ''}
                </div>
            </div>
            <div class="wall right-wall">
                <div class="chest ${state.chestOpen ? '' : 'locked'} interactive" style="left: 35%; bottom: 100px;" data-action="chest1">${state.chestOpen ? 'üì≠' : 'üîê'}</div>
                <div class="bookshelf" style="right: 12%; top: 20%;">
                    <div class="shelf-row"><div class="book interactive" style="background:#8b4513; width:20px;" data-action="book"></div><div class="book interactive" style="background:#2c3e50; width:25px;" data-action="book"></div><div class="book special interactive" style="width:22px;" data-action="specialBook"></div></div>
                    <div class="shelf-row"><div class="book interactive" style="background:#9b59b6; width:22px;" data-action="book"></div><div class="book interactive" style="background:#1abc9c; width:18px;" data-action="book"></div></div>
                    <div class="shelf-row"><div class="book interactive" style="background:#e74c3c; width:20px;" data-action="book"></div></div>
                    <div class="shelf-row"><div class="book interactive" style="background:#f39c12; width:24px;" data-action="book"></div><div class="book interactive" style="background:#3498db; width:20px;" data-action="book"></div></div>
                </div>
            </div>`;
    }

    function escapeRenderRoom2() {
        const state = escapeState.rooms[2];
        const room1State = escapeState.rooms[1];
        return `
            <div class="wall back-wall" style="border-color:#f39c12;">
                <div class="door ${state.doorUnlocked ? 'unlocked' : 'locked'} interactive" style="left:50%;" data-action="door2">üö™</div>
                <div class="door door-back interactive" style="left:20%;" data-action="doorBack1">‚¨ÖÔ∏èüö™</div>
                <div class="power-box ${(!state.fuseInserted || !state.wireInserted) ? 'needs-fuse' : ''} interactive" style="right:18%; top:18%;" data-action="powerBox"><div class="power-light ${state.powerOn ? 'on' : ''}"></div></div>
                <div class="lever-container interactive" style="right:32%; top:18%;" data-action="lever"><div class="lever ${state.leverPulled ? 'pulled' : ''}"></div><span style="color:#888;font-size:12px;">POWER</span></div>
                <div class="vent ${room1State.ventOpen ? 'open' : 'closed'} interactive" style="right:10%; bottom:130px;" data-action="vent2">${Array(12).fill('<div class="vent-slat"></div>').join('')}</div>
            </div>
            <div class="wall left-wall" style="border-color:#f39c12;">
                <div class="note interactive" style="left:50%; top:22%;" data-action="note2">Lab Code:<br>Year the lab<br>was built: 1987</div>
                <div class="safe ${state.safeOpen ? '' : 'locked'} interactive" style="left:62%; bottom:120px;" data-action="safe">${state.safeOpen ? 'üì≠' : 'üîê'}</div>
            </div>
            <div class="wall right-wall" style="border-color:#f39c12;">
                <div class="keypad" style="left:34%; top:22%;">
                    <div class="keypad-display" id="keypadDisplay">${state.powerOn ? '----' : 'NO PWR'}</div>
                    <div class="keypad-buttons">${[1, 2, 3, 4, 5, 6, 7, 8, 9, 'C', 0, '‚úì'].map(n => `<button class="keypad-btn interactive" data-key="${n}" ${!state.powerOn ? 'disabled' : ''}>${n}</button>`).join('')}</div>
                </div>
            </div>`;
    }

    function escapeRenderRoom3() {
        const state = escapeState.rooms[3];
        const allPlaced = state.orbsPlaced.red && state.orbsPlaced.blue && state.orbsPlaced.green;
        return `
            <div class="wall back-wall" style="border-color:#2ecc71;">
                <div class="door ${allPlaced ? 'unlocked' : 'locked'} interactive" data-action="door3">${allPlaced ? 'üö™‚ú®' : 'üö™'}</div>
                <div class="door door-back interactive" data-action="doorBack2">‚¨ÖÔ∏èüö™</div>
                <div class="note interactive" style="right:8%; top:12%; width:140px; height:100px;" data-action="note3">Place the three<br>sacred orbs on<br>their pedestals<br>to obtain the coin.</div>
            </div>
            <div class="wall left-wall" style="border-color:#2ecc71;">
                <div class="interactive" style="position:absolute; left:28%; top:40%; text-align:center;" data-action="orbRed">
                    <div style="width:80px; height:80px; background:${state.orbsPlaced.red ? 'radial-gradient(circle,#ff6b6b,#c0392b)' : '#333'}; border:4px solid #c0392b; border-radius:50%; margin:0 auto; box-shadow:${state.orbsPlaced.red ? '0 0 30px #ff6b6b' : 'none'};"></div>
                    <p style="color:#c0392b; margin-top:10px; font-weight:bold;">RED ORB</p>
                </div>
            </div>
            <div class="wall right-wall" style="border-color:#2ecc71;">
                <div class="interactive" style="position:absolute; left:22%; top:40%; text-align:center;" data-action="orbBlue">
                    <div style="width:80px; height:80px; background:${state.orbsPlaced.blue ? 'radial-gradient(circle,#74b9ff,#0984e3)' : '#333'}; border:4px solid #0984e3; border-radius:50%; margin:0 auto; box-shadow:${state.orbsPlaced.blue ? '0 0 30px #74b9ff' : 'none'};"></div>
                    <p style="color:#0984e3; margin-top:10px; font-weight:bold;">BLUE ORB</p>
                </div>
                <div class="interactive" style="position:absolute; left:52%; top:40%; text-align:center;" data-action="orbGreen">
                    <div style="width:80px; height:80px; background:${state.orbsPlaced.green ? 'radial-gradient(circle,#55efc4,#00b894)' : '#333'}; border:4px solid #00b894; border-radius:50%; margin:0 auto; box-shadow:${state.orbsPlaced.green ? '0 0 30px #55efc4' : 'none'};"></div>
                    <p style="color:#00b894; margin-top:10px; font-weight:bold;">GREEN ORB</p>
                </div>
            </div>`;
    }

    function escapeSetupInteractiveElements() {
        const cursor = document.getElementById('escape-cursor');
        document.querySelectorAll('#escape-room-container .interactive').forEach(el => {
            el.addEventListener('mouseenter', () => cursor.classList.add('hovering'));
            el.addEventListener('mouseleave', () => cursor.classList.remove('hovering'));
        });
    }

    // Escape room click handler
    document.getElementById('escape-room-container').addEventListener('click', (e) => {
        const keypadBtn = e.target.closest('[data-key]');
        if (keypadBtn && !keypadBtn.disabled) {
            e.stopPropagation();
            escapePressKey(keypadBtn.getAttribute('data-key'));
            return;
        }
        if (e.target.classList.contains('wire-node')) {
            e.stopPropagation();
            escapeHandleWireClick(e.target);
            return;
        }
        const clickable = e.target.closest('[data-action]');
        if (!clickable) return;
        e.stopPropagation();
        const action = clickable.getAttribute('data-action');
        switch (action) {
            case 'door1': escapeDoor1Action(); break;
            case 'door2': escapeDoor2Action(); break;
            case 'door3': escapeDoor3Action(); break;
            case 'doorBack1': escapeGoToRoom(1); break;
            case 'doorBack2': escapeGoToRoom(2); break;
            case 'vent1': escapeVent1Action(); break;
            case 'vent2': escapeVent2Action(); break;
            case 'cabinet1': escapeCabinet1Action(); break;
            case 'chest1': escapeChest1Action(); break;
            case 'note1': escapeReadNote1(); break;
            case 'note2': escapeReadNote2(); break;
            case 'note3': escapeReadNote3(); break;
            case 'painting': escapeInspectPainting(); break;
            case 'book': escapeInspectBook(); break;
            case 'specialBook': escapeReadSpecialBook(); break;
            case 'collectKeyInCabinet': escapeCollectKey1(); break;
            case 'powerBox': escapePowerBoxAction(); break;
            case 'lever': escapeLeverAction(); break;
            case 'safe': escapeSafeAction(); break;
            case 'orbRed': escapePlaceOrb('red'); break;
            case 'orbBlue': escapePlaceOrb('blue'); break;
            case 'orbGreen': escapePlaceOrb('green'); break;
        }
    });

    // Inventory slot click handlers
    for (let i = 0; i < 6; i++) {
        document.getElementById('escapeSlot' + i).addEventListener('click', () => escapeSelectInventorySlot(i));
    }

    // Hint button
    document.getElementById('escapeHintBtn').addEventListener('click', () => escapeToggleHint());

    // Modal close buttons
    document.getElementById('closeNoteModal').addEventListener('click', () => escapeCloseModal('escapeNoteModal'));
    document.getElementById('closeBookModal').addEventListener('click', () => escapeCloseModal('escapeBookModal'));
    document.getElementById('closeWireModal').addEventListener('click', () => escapeCloseModal('escapeWireModal'));

    function escapeCollectKey1() {
        const state = escapeState.rooms[1];
        if (escapeAddToInventory('brass_key', 'üîë', 'Brass Key')) {
            state.keyCollected = true;
            document.getElementById('floatingKey1')?.remove();
            escapeRenderRoom(1);
        }
    }

    function escapeReadNote1() {
        document.getElementById('escapeNoteContent').innerHTML = `<strong>The chest remembers the triangle code:</strong><br><br>üî∫ + üî∫ = 6<br>The first number is 2...<br><br><em>What two numbers add to 6 if one is 2?</em>`;
        document.getElementById('escapeNoteModal').style.display = 'flex';
    }

    function escapeInspectPainting() {
        escapeShowMessage("üñºÔ∏è A beautiful landscape. Just decoration.");
    }

    function escapeInspectBook() {
        escapeShowMessage("üìö Just a regular book. Nothing useful here.");
    }

    function escapeReadSpecialBook() {
        document.getElementById('escapeBookContent').innerHTML = `<strong>Ancient Tome of Secrets</strong><br><br>"The three sacred orbs - Red, Blue, and Green - must be united at the final gate."<br><br><em>The red orb lies within the triangular chest...</em>`;
        document.getElementById('escapeBookModal').style.display = 'flex';
    }

    function escapeReadNote2() {
        document.getElementById('escapeNoteContent').innerHTML = `<strong>Laboratory Access Code:</strong><br><br>The lab was established in <strong>1987</strong>.<br><br><em>Use this code on the keypad.</em>`;
        document.getElementById('escapeNoteModal').style.display = 'flex';
    }

    let escapeKeypadInput = '';
    function escapePressKey(key) {
        const state = escapeState.rooms[2];
        if (!state.powerOn) {
            escapeShowMessage("‚ö†Ô∏è No power!");
            return;
        }
        if (key === 'C') {
            escapeKeypadInput = '';
        } else if (key === '‚úì') {
            if (escapeKeypadInput === '1987') {
                state.codeFound = true;
                escapeShowMessage("‚úÖ Correct! A compartment opens - green key and orb!");
                escapeRenderRoom(2);
            } else {
                escapeShowMessage("‚ùå Incorrect code.");
            }
            escapeKeypadInput = '';
        } else {
            if (escapeKeypadInput.length < 4) escapeKeypadInput += key;
        }
        const display = document.getElementById('keypadDisplay');
        if (display) {
            display.textContent = escapeKeypadInput || '----';
        }
    }

    function escapeReadNote3() {
        document.getElementById('escapeNoteContent').innerHTML = `<strong>The Final Chamber</strong><br><br>Place the three sacred orbs on their pedestals:<br><br>üî¥ Red - Room 1's chest (code 24)<br>üîµ Blue - Room 2's safe (green key)<br>üü¢ Green - Room 2 (after keypad)`;
        document.getElementById('escapeNoteModal').style.display = 'flex';
    }

    function escapePlaceOrb(color) {
        const orbId = color + '_orb';
        const state = escapeState.rooms[3];
        if (state.orbsPlaced[color]) {
            escapeShowMessage(`The ${color} orb is already placed.`);
            return;
        }
        if (escapeState.selectedItem === orbId) {
            state.orbsPlaced[color] = true;
            escapeRemoveItem(orbId);
            escapeShowMessage(`‚ú® ${color.charAt(0).toUpperCase() + color.slice(1)} orb placed!`);
            if (state.orbsPlaced.red && state.orbsPlaced.blue && state.orbsPlaced.green) {
                setTimeout(() => {
                    escapeShowMessage("üåü All orbs placed! You obtained the Coin of Charon!");
                    // Complete the puzzle - give coin and return to main game
                    setTimeout(() => {
                        escapeCompleteAndReturn();
                    }, 2000);
                }, 500);
            } else {
                escapeRenderRoom(3);
            }
            return;
        }
        if (escapeHasItem(orbId)) {
            escapeShowMessage(`Select the ${color} orb from inventory, then click here.`);
            return;
        }
        escapeShowMessage(`You need to find the ${color} orb first.`);
    }

    function escapeCompleteAndReturn() {
        // Hide escape room
        document.getElementById('escape-room-container').style.display = 'none';
        
        // Give coin to main game inventory
        inventory[1] = 'coin';
        updateInventoryUI();
        updateHeldItem();
        playSound('collect');
        
        // Return to Styx
        fadeToBlack(() => {
            currentScene = 'styx';
            createRiverStyx();
            
            document.getElementById('body-switch-menu').style.display = 'none';
            
            showNarration("I'm back in my own body... and I have the coin!");
            showNarration("Walk to Charon and press E (or tap Interact) to give him the coin.");
            
            // Position player closer to Charon for easier interaction
            playerPos.set(0, 1.7, 18);
            camera.position.copy(playerPos);
            
            canMove = true;
        });
    }

    function escapeGoToRoom(roomNum) {
        escapeCleanupFloatingItems();
        const overlay = document.getElementById('escapeTransitionOverlay');
        overlay.style.display = 'flex';
        overlay.textContent = `Entering ${escapeState.rooms[roomNum].name}...`;
        setTimeout(() => {
            escapeState.currentRoom = roomNum;
            escapeCurrentHintIndex = 0;
            escapeRenderRoom(roomNum);
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 400);
        }, 600);
    }

    function escapeToggleHint() {
        const popup = document.getElementById('escapeHintPopup');
        if (popup.style.display === 'block') {
            popup.style.display = 'none';
        } else {
            const hints = escapeRoomHints[escapeState.currentRoom];
            document.getElementById('escapeHintText').textContent = hints[escapeCurrentHintIndex % hints.length];
            popup.style.display = 'block';
            escapeCurrentHintIndex++;
        }
    }

    function escapeCloseModal(id) {
        document.getElementById(id).style.display = 'none';
    }

    function escapeShowMessage(text) {
        const existing = document.querySelector('.escape-game-message');
        if (existing) existing.remove();
        const msg = document.createElement('div');
        msg.className = 'escape-game-message';
        msg.style.cssText = `position:fixed; top:30%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.95); color:white; padding:20px 40px; border-radius:15px; font-size:18px; z-index:700; border:2px solid #e94560; text-align:center; max-width:450px; text-shadow:0 0 10px rgba(233,69,96,0.5);`;
        msg.textContent = text;
        document.getElementById('escape-room-container').appendChild(msg);
        setTimeout(() => {
            msg.style.transition = 'all 0.5s';
            msg.style.opacity = '0';
            msg.style.transform = 'translate(-50%,-50%) translateY(-20px)';
            setTimeout(() => msg.remove(), 500);
        }, 2500);
    }

    function escapeDoor1Action() {
        const state = escapeState.rooms[1];
        if (state.doorUnlocked) {
            escapeGoToRoom(2);
            return;
        }
        if (escapeState.selectedItem === 'brass_key') {
            state.doorUnlocked = true;
            escapeRemoveItem('brass_key');
            escapeShowMessage("üîì Door unlocked with brass key! Click again to enter Room 2.");
            escapeRenderRoom(1);
            return;
        }
        if (escapeHasItem('brass_key')) {
            escapeShowMessage("üîë Select the brass key from your inventory (click it), then click this door.");
            return;
        }
        escapeShowMessage("üîí The door is locked. You need to find a key.");
    }

    function escapeVent1Action() {
        const state = escapeState.rooms[1];
        if (state.ventOpen) {
            escapeShowMessage("üîß You crawl through the vent to Room 2... there's a wire there.");
            escapeGoToRoom(2);
            return;
        }
        if (escapeState.selectedItem === 'screwdriver') {
            state.ventOpen = true;
            escapeRemoveItem('screwdriver');
            escapeShowMessage("üîß Vent unscrewed! Crawl through to Room 2 and grab the wire on the other side.");
            escapeRenderRoom(1);
            return;
        }
        if (escapeHasItem('screwdriver')) {
            escapeShowMessage("ü™õ Select the screwdriver from your inventory, then click the vent.");
            return;
        }
        escapeShowMessage("üî© The vent is screwed shut. I need a screwdriver to open this.");
    }

    function escapeCabinet1Action() {
        const state = escapeState.rooms[1];
        if (!state.cabinetOpen) {
            state.cabinetOpen = true;
            escapeShowMessage("üì¶ Cabinet opened! There's a brass key inside.");
            escapeRenderRoom(1);
        } else {
            escapeShowMessage("üì¶ The cabinet is already open.");
        }
    }

    function escapeChest1Action() {
        const state = escapeState.rooms[1];
        if (state.chestOpen) {
            escapeShowMessage("üì≠ The chest is empty.");
            return;
        }
        const code = prompt("Enter 2-digit code:");
        if (code === "24") {
            state.chestOpen = true;
            escapeShowMessage("üéâ Chest opened! You found the Red Orb!");
            escapeAddToInventory('red_orb', 'üî¥', 'Red Orb');
            escapeRenderRoom(1);
        } else if (code !== null) {
            escapeShowMessage("‚ùå Wrong code. Hint: Two triangles, sum is 6, first is 2...");
        }
    }

    function escapeDoor2Action() {
        const state = escapeState.rooms[2];
        if (state.doorUnlocked) {
            escapeGoToRoom(3);
            return;
        }
        if (escapeState.selectedItem === 'gold_key') {
            state.doorUnlocked = true;
            escapeRemoveItem('gold_key');
            escapeShowMessage("üîì Door unlocked with the gold key! Click again to enter Room 3.");
            escapeRenderRoom(2);
            return;
        }
        if (escapeHasItem('gold_key')) {
            escapeShowMessage("üóùÔ∏è Select the gold key from your inventory, then click the door.");
            return;
        }
        escapeShowMessage("üîí This door is locked. Solve the puzzles here and find a key to open it.");
    }

    function escapeVent2Action() {
        const r1 = escapeState.rooms[1];
        if (r1.ventOpen) {
            if (!escapeState.rooms[2].wireCollected && !escapeHasItem('wire')) {
                escapeSpawnFloatingItem('floatingWire', 'üßµ', 'Loose Wire', '75%', '55%', () => {
                    if (escapeAddToInventory('wire', 'üßµ', 'Loose Wire')) {
                        escapeState.rooms[2].wireCollected = true;
                        document.getElementById('floatingWire')?.remove();
                    }
                });
                escapeShowMessage("üßµ The loose wire is here. Grab it!");
            }
            escapeShowMessage("üîß You crawl through the vent back to Room 1...");
            escapeGoToRoom(1);
        } else {
            escapeShowMessage("üî© This vent connects to Room 1, but it's sealed from the other side.");
        }
    }

    function escapePowerBoxAction() {
        const state = escapeState.rooms[2];
        if (state.powerOn) {
            escapeShowMessage("‚ö° Power is already on.");
            return;
        }
        if (escapeState.selectedItem === 'fuse') {
            state.fuseInserted = true;
            escapeRemoveItem('fuse');
            escapeShowMessage("üîå Fuse inserted! The box opens revealing colored terminals.");
            escapeRenderRoom(2);
            return;
        }
        if (state.fuseInserted && !state.wireInserted && escapeState.selectedItem === 'wire') {
            state.wireInserted = true;
            escapeRemoveItem('wire');
            escapeShowMessage("üßµ Wire placed. Connect the colored terminals to finish wiring.");
            escapeOpenWireModal();
            escapeRenderRoom(2);
            return;
        }
        if (!state.fuseInserted || !state.wireInserted) {
            escapeShowMessage("‚ö†Ô∏è The power box needs both a fuse (Room 2 shelf) and a wire (crawl the vent from Room 1). Insert fuse first, then connect the wire to open the wiring panel.");
            return;
        }
        if (state.wireInserted && !state.wirePaired) {
            escapeOpenWireModal();
            escapeShowMessage("üîß Connect the colored wires to finish wiring.");
            return;
        }
        escapeShowMessage("‚ö° Fuse and wire installed. Pull the lever to turn on power.");
    }

    function escapeOpenWireModal() {
        document.getElementById('escapeWireModal').style.display = 'flex';
        document.querySelectorAll('#escape-room-container .wire-node').forEach(n => n.classList.remove('active', 'matched', 'wire-drop-target'));
        escapeDraggingWire = null;
        document.getElementById('escapeWireStatus').textContent = 'Drag a left wire to its matching right terminal.';
    }

    // Wire drag and drop handlers
    document.addEventListener('dragstart', (e) => {
        const node = e.target.closest('#escape-room-container .wire-node[data-side="left"]');
        if (!node) return;
        escapeDraggingWire = node.getAttribute('data-color');
        node.classList.add('active');
        e.dataTransfer.setData('text/plain', escapeDraggingWire);
        document.getElementById('escapeWireStatus').textContent = `Dragging ${escapeDraggingWire.toUpperCase()} wire... drop it on the matching terminal.`;
    });

    document.addEventListener('dragend', (e) => {
        document.querySelectorAll('#escape-room-container .wire-node').forEach(n => n.classList.remove('active', 'wire-drop-target'));
        escapeDraggingWire = null;
    });

    document.addEventListener('dragover', (e) => {
        const target = e.target.closest('#escape-room-container .wire-node[data-side="right"]');
        if (target && !target.classList.contains('matched')) {
            e.preventDefault();
            target.classList.add('wire-drop-target');
        }
    });

    document.addEventListener('dragleave', (e) => {
        const target = e.target.closest('#escape-room-container .wire-node[data-side="right"]');
        if (target) {
            target.classList.remove('wire-drop-target');
        }
    });

    document.addEventListener('drop', (e) => {
        const target = e.target.closest('#escape-room-container .wire-node[data-side="right"]');
        if (!target) return;
        e.preventDefault();
        const color = target.getAttribute('data-color');
        if (!escapeDraggingWire) return;
        if (color === escapeDraggingWire) {
            const leftNode = document.querySelector(`#escape-room-container .wire-node[data-side="left"][data-color="${color}"]`);
            leftNode.classList.add('matched');
            target.classList.add('matched');
            target.classList.remove('wire-drop-target');
            document.getElementById('escapeWireStatus').textContent = `${color.toUpperCase()} connected!`;
            // Check all matched
            const allMatched = Array.from(document.querySelectorAll('#escape-room-container .wire-node')).filter(n => n.getAttribute('data-side') === 'left').every(n => n.classList.contains('matched'));
            if (allMatched) {
                const state = escapeState.rooms[2];
                state.wirePaired = true;
                escapeCloseModal('escapeWireModal');
                escapeShowMessage('‚úÖ Wires connected! Pull the lever to power the keypad.');
            }
        } else {
            document.getElementById('escapeWireStatus').textContent = `Wrong terminal for ${escapeDraggingWire.toUpperCase()}. Try again.`;
        }
        document.querySelectorAll('#escape-room-container .wire-node').forEach(n => n.classList.remove('active', 'wire-drop-target'));
        escapeDraggingWire = null;
    });

    function escapeLeverAction() {
        const state = escapeState.rooms[2];
        if (state.leverPulled) {
            escapeShowMessage("The lever is already pulled.");
            return;
        }
        if (!state.fuseInserted || !state.wireInserted || !state.wirePaired) {
            escapeShowMessage("‚ö†Ô∏è No power. Insert fuse + wire, connect the colored wires, then pull the lever.");
            return;
        }
        state.leverPulled = true;
        state.powerOn = true;
        escapeShowMessage("‚ö° Power restored! The keypad is now active.");
        escapeRenderRoom(2);
    }

    function escapeSafeAction() {
        const state = escapeState.rooms[2];
        if (state.safeOpen) {
            escapeShowMessage("üì≠ The safe is empty.");
            return;
        }
        if (escapeState.selectedItem === 'green_key') {
            state.safeOpen = true;
            escapeRemoveItem('green_key');
            escapeShowMessage("üîì Safe opened! You found a Gold Key and the Blue Orb!");
            escapeAddToInventory('gold_key', 'üóùÔ∏è', 'Gold Key');
            escapeAddToInventory('blue_orb', 'üîµ', 'Blue Orb');
            escapeRenderRoom(2);
            return;
        }
        if (escapeHasItem('green_key')) {
            escapeShowMessage("üóùÔ∏è Select the green key from your inventory, then click the safe.");
            return;
        }
        escapeShowMessage("üîí This safe needs a special key. Solve the keypad puzzle to find it.");
    }

    function escapeDoor3Action() {
        const state = escapeState.rooms[3];
        if (state.orbsPlaced.red && state.orbsPlaced.blue && state.orbsPlaced.green) {
            escapeShowMessage("üåü The door glows brightly! You have completed the trial!");
            setTimeout(() => {
                escapeCompleteAndReturn();
            }, 1500);
        } else {
            let missing = [];
            if (!state.orbsPlaced.red) missing.push('Red');
            if (!state.orbsPlaced.blue) missing.push('Blue');
            if (!state.orbsPlaced.green) missing.push('Green');
            escapeShowMessage(`üîí Missing orbs: ${missing.join(', ')}`);
        }
    }

    // Escape key handler for modals
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            escapeCloseModal('escapeNoteModal');
            escapeCloseModal('escapeBookModal');
            escapeCloseModal('escapeWireModal');
        }
    });

  </script>
</body>
</html>
